{"version":3,"sources":["state/atoms.ts","state/constants.ts","algorithms/common.ts","components/GridNode.tsx","algorithms/dijkstra.ts","components/Grid.tsx","components/App.tsx","index.tsx"],"names":["isDrawingWallsAtom","atom","key","default","isVisualizedAtom","isMovingStartAtom","isMovingEndAtom","nodeAtom","atomFamily","row","column","position","flags","isWall","isVisited","distance","Infinity","createNode","nodeClassesAtom","NUM_OF_NODES","getIndex","GridNode","visitedNumber","pathNumber","visitedCount","setIsStartPosition","setIsEndPosition","isDrawingWalls","useRecoilValue","isVisualized","useRecoilState","isMovingStart","setIsMovingStart","isMovingEnd","setIsMovingEnd","node","setNode","useState","isStart","setIsStart","isEnd","setIsEnd","getClassNames","useCallback","wallClass","classNames","classes","setClasses","isStartPosition","undefined","isEndPosition","useEffect","timeouts","pathTimerId","setTimeout","getPathNodeDelay","push","visitTimerId","getVisitedNodeDelay","forEach","timeout","clearTimeout","drawWall","className","onMouseOver","onMouseDown","onMouseLeave","onMouseUp","nodeDistanceComparator","a","b","getNeighbours","grid","index","neighbours","startPositionFuncs","endPositionFuncs","getArrayIndex","array","length","findIndex","getNodePositionFromChildren","positionFuncs","nodePosition","childPosition","positionFunc","Grid","setOnVisualize","setOnClear","childStartPosition","childIndex","childEndPosition","setIsDrawingWalls","useSetRecoilState","setIsVisualized","visitedNodes","setVisitedNodes","shortestPathNodes","setShortestPathNodes","visualizeDijkstra","resetGridState","getGridState","useRecoilCallback","getLoadable","snapshot","nodes","i","j","getValue","reset","startNodePosition","endNodePosition","newVisitedNodes","startPosition","endPosition","priorityQueue","Heap","init","seenIndices","Set","closestNode","pop","isEndNode","has","add","neighbour","newDistance","newNeighbour","JSON","parse","stringify","parent","isEmpty","dijkstra","endNode","shortestPath","getShortestPath","Array","from","NUM_OF_ROWS","keys","map","Math","floor","slice","reverse","visualizeGrid","resetGrid","App","Box","Button","sx","m","variant","onClick","childVisualize","childClear","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.46f440a0.chunk.js","sourcesContent":["import { atom, atomFamily } from \"recoil\";\r\nimport { Node } from \"../types\";\r\n\r\nconst createNode = (row: number, column: number): Node => {\r\n  return {\r\n    position: {\r\n      row,\r\n      column,\r\n    },\r\n    flags: {\r\n      isWall: false,\r\n      isVisited: false,\r\n    },\r\n    distance: Infinity,\r\n  };\r\n};\r\n\r\nexport const isDrawingWallsAtom = atom<boolean>({\r\n  key: \"isDrawingWalls\",\r\n  default: false,\r\n});\r\n\r\nexport const isVisualizedAtom = atom<boolean>({\r\n  key: \"isVisualized\",\r\n  default: false,\r\n});\r\n\r\nexport const isMovingStartAtom = atom<boolean>({\r\n  key: \"isMovingStart\",\r\n  default: false,\r\n});\r\n\r\nexport const isMovingEndAtom = atom<boolean>({\r\n  key: \"isMovingEnd\",\r\n  default: false,\r\n});\r\n\r\nexport const nodeAtom = atomFamily<Node, number[]>({\r\n  key: \"grid\",\r\n  default: ([row, column]) => createNode(row, column),\r\n});\r\n\r\nexport const nodeClassesAtom = atomFamily<string, number[]>({\r\n  key: \"nodeClasses\",\r\n  default: \"node\",\r\n});\r\n","export const NUM_OF_ROWS = 20;\r\nexport const NUM_OF_NODES = 50;\r\n","import { Node, NodePosition } from \"../types\";\r\nimport { NUM_OF_NODES } from \"../state/constants\";\r\n\r\nexport const getIndex = ({ position: { row, column } }: Node): number => {\r\n  return row * NUM_OF_NODES + column;\r\n};\r\n\r\nexport const isEndNode = (node: Node, endPosition: NodePosition): boolean => {\r\n  return (\r\n    node.position.row === endPosition.row &&\r\n    node.position.column === endPosition.column\r\n  );\r\n};\r\n","import classNames from \"classnames\";\nimport React, { useEffect, useState } from \"react\";\nimport { VscDebugStart } from \"react-icons/vsc\";\nimport { FaMapMarkerAlt } from \"react-icons/fa\";\nimport { useCallback } from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport \"../css/gridNode.scss\";\nimport {\n  isDrawingWallsAtom,\n  isMovingStartAtom,\n  isMovingEndAtom,\n  isVisualizedAtom,\n  nodeAtom,\n  nodeClassesAtom,\n} from \"../state/atoms\";\nimport { NodePosition } from \"../types\";\nimport { getIndex } from \"../algorithms/common\";\n\nconst PATH_CLASS = \"path\";\nconst VISITED_CLASS = \"visited\";\n\ninterface NodeProps {\n  position: NodePosition;\n  visitedNumber: number;\n  visitedCount: number;\n  pathNumber: number;\n  setIsStartPosition: any;\n  setIsEndPosition: any;\n}\n\nconst getPathNodeDelay = (visitedCount: number, pathNumber: number): number => {\n  return 4 * visitedCount + 5 * (pathNumber + 1);\n};\n\nconst getVisitedNodeDelay = (visitedNumber: number) => {\n  return 4 * (visitedNumber + 1);\n};\n\nconst GridNode = ({\n  position: { row, column },\n  visitedNumber,\n  pathNumber,\n  visitedCount,\n  setIsStartPosition,\n  setIsEndPosition,\n}: NodeProps) => {\n  const isDrawingWalls = useRecoilValue(isDrawingWallsAtom);\n  const isVisualized = useRecoilValue(isVisualizedAtom);\n  const [isMovingStart, setIsMovingStart] = useRecoilState(isMovingStartAtom);\n  const [isMovingEnd, setIsMovingEnd] = useRecoilState(isMovingEndAtom);\n  const [node, setNode] = useRecoilState(nodeAtom([row, column]));\n  const [isStart, setIsStart] = useState<boolean>(row === 10 && column === 5);\n  const [isEnd, setIsEnd] = useState<boolean>(row === 10 && column === 45);\n  const getClassNames = useCallback((isWall: boolean): string => {\n    const wallClass = isWall ? \"wall\" : \"\";\n    return classNames(\"node\", wallClass);\n  }, []);\n\n  const [classes, setClasses] = useRecoilState<string>(\n    nodeClassesAtom([row, column])\n  );\n  const isStartPosition = () => {\n    return isStart ? { row, column } : undefined;\n  };\n  const isEndPosition = () => {\n    return isEnd ? { row, column } : undefined;\n  };\n  useEffect(() => {\n    setIsStartPosition(isStartPosition, getIndex(node));\n    setIsEndPosition(isEndPosition, getIndex(node));\n  });\n  useEffect(() => {\n    const timeouts: NodeJS.Timeout[] = [];\n    if (visitedNumber !== -1 && !node.flags.isVisited) {\n      const visitTimerId = setTimeout(() => {\n        setNode({\n          ...node,\n          flags: {\n            ...node.flags,\n            isVisited: true,\n          },\n        });\n        setClasses(classNames(getClassNames(node.flags.isWall), VISITED_CLASS));\n      }, getVisitedNodeDelay(visitedNumber));\n      timeouts.push(visitTimerId);\n    } else if (pathNumber !== -1) {\n      const pathTimerId = setTimeout(() => {\n        setClasses(classNames(getClassNames(node.flags.isWall), PATH_CLASS));\n      }, getPathNodeDelay(visitedCount, pathNumber));\n      timeouts.push(pathTimerId);\n    }\n    return () => {\n      timeouts.forEach((timeout) => {\n        clearTimeout(timeout);\n      });\n    };\n  }, [\n    getClassNames,\n    classes,\n    visitedNumber,\n    node,\n    pathNumber,\n    setNode,\n    setClasses,\n    visitedCount,\n  ]);\n  const handleMouseOver = () => {\n    if (isMovingStart) {\n      setIsStart(true);\n    } else if (isMovingEnd) {\n      setIsEnd(true);\n    } else if (isDrawingWalls) {\n      drawWall();\n    }\n  };\n\n  const handleMouseDown = () => {\n    if (isStart && !isVisualized) {\n      setIsMovingStart(true);\n    } else if (isEnd && !isVisualized) {\n      setIsMovingEnd(true);\n    } else {\n      drawWall();\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (isStart && isMovingStart) {\n      setIsStart(false);\n    } else if (isEnd && isMovingEnd) {\n      setIsEnd(false);\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsMovingStart(false);\n    setIsMovingEnd(false);\n  };\n\n  const drawWall = () => {\n    if (!isVisualized) {\n      setNode({\n        ...node,\n        flags: {\n          ...node.flags,\n          isWall: !node.flags.isWall,\n        },\n      });\n      setClasses(getClassNames(!node.flags.isWall));\n    }\n  };\n  return (\n    <div\n      className={classes}\n      onMouseOver={handleMouseOver}\n      onMouseDown={handleMouseDown}\n      onMouseLeave={handleMouseLeave}\n      onMouseUp={handleMouseUp}\n    >\n      {isStart && <VscDebugStart className=\"icon\" />}\n      {isEnd && <FaMapMarkerAlt className=\"icon\" />}\n    </div>\n  );\n};\n\nexport default GridNode;\n","import Heap from \"heap-js\";\r\nimport { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\nimport { Node, NodePosition } from \"../types\";\r\nimport { getIndex, isEndNode } from \"./common\";\r\n\r\nconst nodeDistanceComparator = (a: Node, b: Node) => a.distance - b.distance;\r\n\r\nexport const dijkstra = (\r\n  grid: Node[],\r\n  startPosition: NodePosition,\r\n  endPosition: NodePosition\r\n): Node[] => {\r\n  const visitedNodes: Node[] = [];\r\n  if (!grid || startPosition === endPosition) {\r\n    return visitedNodes;\r\n  }\r\n  //Set start node distance to 0\r\n  grid[startPosition.row * NUM_OF_NODES + startPosition.column].distance = 0;\r\n  const priorityQueue = new Heap(nodeDistanceComparator);\r\n  priorityQueue.init(grid);\r\n  const seenIndices = new Set<number>();\r\n  while (!priorityQueue.isEmpty()) {\r\n    const closestNode = priorityQueue.pop();\r\n    if (!closestNode || closestNode.distance === Infinity) {\r\n      break;\r\n    }\r\n    if (isEndNode(closestNode, endPosition)) {\r\n      visitedNodes.push(closestNode);\r\n      break;\r\n    }\r\n    if (closestNode.flags.isWall) {\r\n      continue;\r\n    }\r\n    const index = getIndex(closestNode);\r\n    if (!seenIndices.has(index)) {\r\n      seenIndices.add(index);\r\n      const neighbours = getNeighbours(grid, index);\r\n      neighbours.forEach((neighbour) => {\r\n        const newDistance = closestNode.distance + 1;\r\n        if (newDistance < neighbour.distance) {\r\n          const newNeighbour: Node = JSON.parse(JSON.stringify(neighbour));\r\n          newNeighbour.distance = newDistance;\r\n          newNeighbour.parent = closestNode;\r\n          priorityQueue.push(newNeighbour);\r\n        }\r\n      });\r\n      visitedNodes.push(closestNode);\r\n    }\r\n  }\r\n  return visitedNodes;\r\n};\r\n\r\nconst getNeighbours = (grid: Node[], index: number): Node[] => {\r\n  const neighbours: Node[] = [];\r\n  if (index % NUM_OF_NODES !== NUM_OF_NODES - 1) {\r\n    neighbours.push(grid[index + 1]);\r\n  }\r\n  if (index % NUM_OF_NODES !== 0) {\r\n    neighbours.push(grid[index - 1]);\r\n  }\r\n  if (index >= NUM_OF_NODES) {\r\n    neighbours.push(grid[index - NUM_OF_NODES]);\r\n  }\r\n  if (index < NUM_OF_NODES * (NUM_OF_ROWS - 1)) {\r\n    neighbours.push(grid[index + NUM_OF_NODES]);\r\n  }\r\n  return neighbours;\r\n};\r\n","import React, { useEffect, useState } from \"react\";\r\nimport { useSetRecoilState, useRecoilCallback } from \"recoil\";\r\nimport \"../css/grid.scss\";\r\nimport {\r\n  isDrawingWallsAtom,\r\n  nodeAtom,\r\n  nodeClassesAtom,\r\n  isVisualizedAtom,\r\n} from \"../state/atoms\";\r\nimport { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\nimport GridNode from \"./GridNode\";\r\nimport { Node, NodePosition } from \"../types\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\n\r\ninterface GridProps {\r\n  setOnVisualize: (childVisualize: () => void) => void;\r\n  setOnClear: (childClear: () => void) => void;\r\n}\r\n\r\nlet startPositionFuncs: (() => NodePosition)[] = [];\r\nlet endPositionFuncs: (() => NodePosition)[] = [];\r\n\r\nconst getShortestPath = (endNode: Node): Node[] => {\r\n  const shortestPath: Node[] = [];\r\n  let node: Node | undefined = endNode;\r\n  while (node) {\r\n    shortestPath.push(node);\r\n    node = node.parent;\r\n  }\r\n  return shortestPath;\r\n};\r\n\r\nconst getArrayIndex = (array: Node[], row: number, column: number): number => {\r\n  return array.length !== 0\r\n    ? array.findIndex(\r\n        (node) => node.position.row === row && node.position.column === column\r\n      )\r\n    : -1;\r\n};\r\n\r\nconst getNodePositionFromChildren = (\r\n  positionFuncs: (() => NodePosition)[]\r\n): NodePosition => {\r\n  let nodePosition = { row: -1, column: -1 };\r\n  for (let positionFunc of positionFuncs) {\r\n    const childPosition = positionFunc();\r\n    if (childPosition) {\r\n      nodePosition = childPosition;\r\n      break;\r\n    }\r\n  }\r\n  return nodePosition;\r\n};\r\n\r\nconst getStartNodePosition = (): NodePosition => {\r\n  return getNodePositionFromChildren(startPositionFuncs);\r\n};\r\n\r\nconst getEndNodePosition = (): NodePosition => {\r\n  return getNodePositionFromChildren(endPositionFuncs);\r\n};\r\n\r\nconst Grid = ({ setOnVisualize, setOnClear }: GridProps) => {\r\n  const setIsStartPosition = (\r\n    childStartPosition: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    startPositionFuncs[childIndex] = childStartPosition;\r\n  };\r\n  const setIsEndPosition = (\r\n    childEndPosition: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    endPositionFuncs[childIndex] = childEndPosition;\r\n  };\r\n  const setIsDrawingWalls = useSetRecoilState(isDrawingWallsAtom);\r\n  const setIsVisualized = useSetRecoilState(isVisualizedAtom);\r\n  const [visitedNodes, setVisitedNodes] = useState<Node[]>([]);\r\n  const [shortestPathNodes, setShortestPathNodes] = useState<Node[]>([]);\r\n  useEffect(() => {\r\n    setOnVisualize(() => {\r\n      visualizeDijkstra();\r\n      setIsVisualized(true);\r\n    });\r\n    setOnClear(() => {\r\n      resetGridState();\r\n      setVisitedNodes([]);\r\n      setShortestPathNodes([]);\r\n      setIsVisualized(false);\r\n    });\r\n  });\r\n  const getGridState = useRecoilCallback(\r\n    ({ snapshot: { getLoadable } }) =>\r\n      () => {\r\n        let nodes: Node[] = [];\r\n        for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n          for (let j = 0; j < NUM_OF_NODES; j++) {\r\n            nodes = [...nodes, getLoadable(nodeAtom([i, j])).getValue()];\r\n          }\r\n        }\r\n        return nodes;\r\n      }\r\n  );\r\n  const resetGridState = useRecoilCallback(({ reset }) => () => {\r\n    for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n      for (let j = 0; j < NUM_OF_NODES; j++) {\r\n        reset(nodeAtom([i, j]));\r\n        reset(nodeClassesAtom([i, j]));\r\n      }\r\n    }\r\n  });\r\n  const visualizeDijkstra = () => {\r\n    const startNodePosition = getStartNodePosition();\r\n    const endNodePosition = getEndNodePosition();\r\n    const newVisitedNodes = dijkstra(\r\n      getGridState(),\r\n      startNodePosition,\r\n      endNodePosition\r\n    );\r\n    const endNode = newVisitedNodes[newVisitedNodes.length - 1];\r\n    if (\r\n      endNode.position.row === endNodePosition.row &&\r\n      endNode.position.column === endNodePosition.column\r\n    ) {\r\n      setShortestPathNodes(getShortestPath(endNode));\r\n    }\r\n    setVisitedNodes(newVisitedNodes);\r\n  };\r\n  return (\r\n    <div\r\n      className=\"grid\"\r\n      onMouseDown={() => setIsDrawingWalls(true)}\r\n      onMouseUp={() => setIsDrawingWalls(false)}\r\n    >\r\n      {Array.from(Array(NUM_OF_ROWS * NUM_OF_NODES).keys()).map((index) => {\r\n        const row = Math.floor(index / NUM_OF_NODES);\r\n        const column = index % NUM_OF_NODES;\r\n        return (\r\n          <GridNode\r\n            position={{ row, column }}\r\n            visitedNumber={getArrayIndex(visitedNodes, row, column)}\r\n            visitedCount={visitedNodes.length}\r\n            pathNumber={getArrayIndex(\r\n              shortestPathNodes.slice().reverse(),\r\n              row,\r\n              column\r\n            )}\r\n            setIsStartPosition={setIsStartPosition}\r\n            setIsEndPosition={setIsEndPosition}\r\n            key={index}\r\n          ></GridNode>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import React from \"react\";\r\nimport Grid from \"./Grid\";\r\nimport Button from \"@mui/material/Button\";\r\nimport Box from \"@mui/material/Box\";\r\nimport \"../css/app.scss\";\r\n\r\nlet visualizeGrid: () => void = () => { };\r\nlet resetGrid: () => void = () => { };\r\n\r\nconst App = () => {\r\n  const setOnVisualize = (childVisualize: () => void) => {\r\n    visualizeGrid = childVisualize;\r\n  };\r\n  const setOnClear = (childClear: () => void) => {\r\n    resetGrid = childClear;\r\n  };\r\n  return (\r\n    <div className=\"container\">\r\n      <Box>\r\n        <Button\r\n          sx={{ m: 5 }}\r\n          variant=\"contained\"\r\n          onClick={() => visualizeGrid()}\r\n        >\r\n          Visualize!\r\n        </Button>\r\n        <Button sx={{ m: 5 }} variant=\"contained\" onClick={() => resetGrid()}>\r\n          Clear grid\r\n        </Button>\r\n      </Box>\r\n      <Grid setOnVisualize={setOnVisualize} setOnClear={setOnClear}></Grid>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { RecoilRoot } from \"recoil\";\r\nimport \"./css/index.scss\";\r\nimport App from \"./components/App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <RecoilRoot>\r\n      <App />\r\n    </RecoilRoot>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}