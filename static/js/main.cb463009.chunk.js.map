{"version":3,"sources":["types.ts","state/atoms.ts","state/constants.ts","algorithms/common.ts","components/GridNode.tsx","algorithms/dijkstra.ts","algorithms/astar.ts","components/Grid.tsx","components/Controls.tsx","components/App.tsx","index.tsx"],"names":["Algorithm","isDrawingWallsAtom","atom","key","default","isVisualizedAtom","isMovingStartAtom","isMovingEndAtom","nodeAtom","atomFamily","row","column","position","flags","isWall","isVisited","createNode","visitedNodesAtom","shortestPathNodesAtom","selectedAlgorithmAtom","Dijkstra","nodeClassesAtom","NUM_OF_NODES","getIndex","isEndNode","node","endPosition","getNeighbours","grid","index","neighbours","push","GridNode","visitedNumber","pathNumber","visitedCount","setIsStartPosition","setIsEndPosition","setResetNode","isDrawingWalls","useRecoilValue","isVisualized","useRecoilState","isMovingStart","setIsMovingStart","isMovingEnd","setIsMovingEnd","setNode","useState","isStart","setIsStart","isEnd","setIsEnd","getClassNames","useCallback","wallClass","classNames","classes","setClasses","isStartPosition","undefined","isEndPosition","resetNode","useEffect","timeouts","pathTimerId","setTimeout","getPathNodeDelay","visitTimerId","ReactDOM","unstable_batchedUpdates","getVisitedNodeDelay","forEach","timeout","clearTimeout","drawWall","className","onMouseOver","onMouseDown","onMouseLeave","onMouseUp","nodeDistanceComparator","a","b","aProps","props","bProps","distance","Infinity","distanceDifference","getDistance","setDistance","nodeFComparator","f","fDifference","manhattanDistance","Math","abs","getGScore","g","setGScore","value","setFScore","startPositionFuncs","endPositionFuncs","resetNodeFuncs","getArrayIndex","array","length","findIndex","getNodePositionFromChildren","positionFuncs","nodePosition","childPosition","positionFunc","Grid","setOnVisualize","setOnClear","childStartPosition","childIndex","childEndPosition","childResetNode","setIsDrawingWalls","useSetRecoilState","setIsVisualized","visitedNodes","setVisitedNodes","shortestPathNodes","setShortestPathNodes","selectedAlgorithm","visualizeAlgorithm","resetFunc","resetGridState","getGridState","useRecoilCallback","getLoadable","snapshot","nodes","i","j","nodeValue","getValue","JSON","parse","stringify","reset","startNodePosition","endNodePosition","gridNodes","newVisitedNodes","startPosition","priorityQueue","Heap","init","seenIndices","Set","closestNode","pop","has","add","neighbour","newDistance","newNeighbour","parent","isEmpty","dijkstra","AStar","startNode","discoveredNodes","currentNode","currentProps","newScore","aStar","endNode","shortestPath","getShortestPath","Array","from","NUM_OF_ROWS","keys","map","floor","slice","reverse","Controls","visualizeGrid","resetGrid","setSelectedAlgorithm","Box","FormControl","fullWidth","InputLabel","id","Select","labelId","label","onChange","event","target","defaultValue","MenuItem","Button","sx","m","variant","onClick","App","childVisualize","childClear","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cb463009.chunk.js","sourcesContent":["export interface Node {\r\n  position: NodePosition;\r\n  flags: NodeFlags;\r\n  parent?: Node;\r\n  props?: any;\r\n}\r\n\r\nexport interface DijkstraProps {\r\n  distance: number;\r\n}\r\n\r\nexport interface AStarProps {\r\n  f: number;\r\n  g: number;\r\n}\r\n\r\nexport interface NodePosition {\r\n  row: number;\r\n  column: number;\r\n}\r\n\r\nexport interface NodeFlags {\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n}\r\n\r\nexport enum Algorithm {\r\n  Dijkstra = \"Dijkstra\",\r\n  AStar = \"A*\",\r\n}\r\n","import { atom, atomFamily } from \"recoil\";\r\nimport { Algorithm, Node } from \"../types\";\r\n\r\nconst createNode = (row: number, column: number): Node => {\r\n  return {\r\n    position: {\r\n      row,\r\n      column,\r\n    },\r\n    flags: {\r\n      isWall: false,\r\n      isVisited: false,\r\n    },\r\n  };\r\n};\r\n\r\nexport const isDrawingWallsAtom = atom<boolean>({\r\n  key: \"isDrawingWalls\",\r\n  default: false,\r\n});\r\n\r\nexport const isVisualizedAtom = atom<boolean>({\r\n  key: \"isVisualized\",\r\n  default: false,\r\n});\r\n\r\nexport const isMovingStartAtom = atom<boolean>({\r\n  key: \"isMovingStart\",\r\n  default: false,\r\n});\r\n\r\nexport const isMovingEndAtom = atom<boolean>({\r\n  key: \"isMovingEnd\",\r\n  default: false,\r\n});\r\n\r\nexport const nodeAtom = atomFamily<Node, number[]>({\r\n  key: \"grid\",\r\n  default: ([row, column]) => createNode(row, column),\r\n});\r\n\r\nexport const visitedNodesAtom = atom<Node[]>({\r\n  key: \"visitedNodes\",\r\n  default: [],\r\n});\r\n\r\nexport const shortestPathNodesAtom = atom<Node[]>({\r\n  key: \"shortestPathNodes\",\r\n  default: [],\r\n});\r\n\r\nexport const selectedAlgorithmAtom = atom<string>({\r\n  key: \"selectedAlgorithm\",\r\n  default: Algorithm.Dijkstra,\r\n});\r\n\r\nexport const nodeClassesAtom = atomFamily<string, number[]>({\r\n  key: \"nodeClasses\",\r\n  default: \"node\",\r\n});\r\n","export const NUM_OF_ROWS = 20;\r\nexport const NUM_OF_NODES = 50;\r\nexport const DEFAULT_START_ROW = 10;\r\nexport const DEFAULT_START_COLUMN = 5;\r\nexport const DEFAULT_END_ROW = 10;\r\nexport const DEFAULT_END_COLUMN = 45;\r\n","import { Node, NodePosition } from \"../types\";\r\nimport { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\n\r\nexport const getIndex = ({ position: { row, column } }: Node): number => {\r\n  return row * NUM_OF_NODES + column;\r\n};\r\n\r\nexport const isEndNode = (node: Node, endPosition: NodePosition): boolean => {\r\n  return (\r\n    node.position.row === endPosition.row &&\r\n    node.position.column === endPosition.column\r\n  );\r\n};\r\n\r\nexport const getNeighbours = (grid: Node[], index: number): Node[] => {\r\n  const neighbours: Node[] = [];\r\n  if (index % NUM_OF_NODES !== NUM_OF_NODES - 1) {\r\n    neighbours.push(grid[index + 1]);\r\n  }\r\n  if (index % NUM_OF_NODES !== 0) {\r\n    neighbours.push(grid[index - 1]);\r\n  }\r\n  if (index >= NUM_OF_NODES) {\r\n    neighbours.push(grid[index - NUM_OF_NODES]);\r\n  }\r\n  if (index < NUM_OF_NODES * (NUM_OF_ROWS - 1)) {\r\n    neighbours.push(grid[index + NUM_OF_NODES]);\r\n  }\r\n  return neighbours;\r\n};\r\n","import classNames from \"classnames\";\nimport React, { useEffect, useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { VscDebugStart } from \"react-icons/vsc\";\nimport { FaMapMarkerAlt } from \"react-icons/fa\";\nimport { useCallback } from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport \"../css/gridNode.scss\";\nimport {\n  isDrawingWallsAtom,\n  isMovingStartAtom,\n  isMovingEndAtom,\n  isVisualizedAtom,\n  nodeAtom,\n  nodeClassesAtom,\n} from \"../state/atoms\";\nimport { NodePosition } from \"../types\";\nimport { getIndex } from \"../algorithms/common\";\nimport {\n  DEFAULT_END_COLUMN,\n  DEFAULT_END_ROW,\n  DEFAULT_START_COLUMN,\n  DEFAULT_START_ROW,\n} from \"../state/constants\";\n\nconst PATH_CLASS = \"path\";\nconst VISITED_CLASS = \"visited\";\n\ninterface NodeProps {\n  position: NodePosition;\n  visitedNumber: number;\n  visitedCount: number;\n  pathNumber: number;\n  setIsStartPosition: any;\n  setIsEndPosition: any;\n  setResetNode: any;\n}\n\nconst getPathNodeDelay = (visitedCount: number, pathNumber: number): number => {\n  return 4 * visitedCount + 5 * (pathNumber + 1);\n};\n\nconst getVisitedNodeDelay = (visitedNumber: number) => {\n  return 4 * (visitedNumber + 1);\n};\n\nconst GridNode = ({\n  position: { row, column },\n  visitedNumber,\n  pathNumber,\n  visitedCount,\n  setIsStartPosition,\n  setIsEndPosition,\n  setResetNode,\n}: NodeProps) => {\n  const isDrawingWalls = useRecoilValue(isDrawingWallsAtom);\n  const isVisualized = useRecoilValue(isVisualizedAtom);\n  const [isMovingStart, setIsMovingStart] = useRecoilState(isMovingStartAtom);\n  const [isMovingEnd, setIsMovingEnd] = useRecoilState(isMovingEndAtom);\n  const [node, setNode] = useRecoilState(nodeAtom([row, column]));\n  const isDefaultStart = () =>\n    row === DEFAULT_START_ROW && column === DEFAULT_START_COLUMN;\n  const isDefaultEnd = () =>\n    row === DEFAULT_END_ROW && column === DEFAULT_END_COLUMN;\n  const [isStart, setIsStart] = useState<boolean>(isDefaultStart());\n  const [isEnd, setIsEnd] = useState<boolean>(isDefaultEnd());\n  const getClassNames = useCallback((isWall: boolean): string => {\n    const wallClass = isWall ? \"wall\" : \"\";\n    return classNames(\"node\", wallClass);\n  }, []);\n\n  const [classes, setClasses] = useRecoilState<string>(\n    nodeClassesAtom([row, column])\n  );\n  const isStartPosition = () => {\n    return isStart ? { row, column } : undefined;\n  };\n  const isEndPosition = () => {\n    return isEnd ? { row, column } : undefined;\n  };\n  const resetNode = () => {};\n  useEffect(() => {\n    setIsStartPosition(isStartPosition, getIndex(node));\n    setIsEndPosition(isEndPosition, getIndex(node));\n    setResetNode(resetNode, getIndex(node));\n  });\n  useEffect(() => {\n    const timeouts: NodeJS.Timeout[] = [];\n    if (visitedNumber !== -1 && !node.flags.isVisited) {\n      const visitTimerId = setTimeout(() => {\n        ReactDOM.unstable_batchedUpdates(() => {\n          setNode({\n            ...node,\n            flags: {\n              ...node.flags,\n              isVisited: true,\n            },\n          });\n          setClasses(\n            classNames(getClassNames(node.flags.isWall), VISITED_CLASS)\n          );\n        });\n      }, getVisitedNodeDelay(visitedNumber));\n      timeouts.push(visitTimerId);\n    } else if (pathNumber !== -1) {\n      const pathTimerId = setTimeout(() => {\n        setClasses(classNames(getClassNames(node.flags.isWall), PATH_CLASS));\n      }, getPathNodeDelay(visitedCount, pathNumber));\n      timeouts.push(pathTimerId);\n    }\n    return () => {\n      timeouts.forEach((timeout) => {\n        clearTimeout(timeout);\n      });\n    };\n  }, [\n    getClassNames,\n    classes,\n    visitedNumber,\n    node,\n    pathNumber,\n    setNode,\n    setClasses,\n    visitedCount,\n  ]);\n  const handleMouseOver = () => {\n    if (isMovingStart) {\n      setIsStart(true);\n    } else if (isMovingEnd) {\n      setIsEnd(true);\n    } else if (isDrawingWalls) {\n      drawWall();\n    }\n  };\n\n  const handleMouseDown = () => {\n    if (isStart && !isVisualized) {\n      setIsMovingStart(true);\n    } else if (isEnd && !isVisualized) {\n      setIsMovingEnd(true);\n    } else {\n      drawWall();\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (isStart && isMovingStart) {\n      setIsStart(false);\n    } else if (isEnd && isMovingEnd) {\n      setIsEnd(false);\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsMovingStart(false);\n    setIsMovingEnd(false);\n  };\n\n  const drawWall = () => {\n    if (!isVisualized) {\n      setNode({\n        ...node,\n        flags: {\n          ...node.flags,\n          isWall: !node.flags.isWall,\n        },\n      });\n      setClasses(getClassNames(!node.flags.isWall));\n    }\n  };\n  return (\n    <div\n      className={classes}\n      onMouseOver={handleMouseOver}\n      onMouseDown={handleMouseDown}\n      onMouseLeave={handleMouseLeave}\n      onMouseUp={handleMouseUp}\n    >\n      {isStart && <VscDebugStart className=\"icon\" />}\n      {isEnd && <FaMapMarkerAlt className=\"icon\" />}\n    </div>\n  );\n};\n\nexport default GridNode;\n","import Heap from \"heap-js\";\r\nimport { NUM_OF_NODES } from \"../state/constants\";\r\nimport { DijkstraProps, Node, NodePosition } from \"../types\";\r\nimport { getIndex, isEndNode, getNeighbours } from \"./common\";\r\n\r\nconst nodeDistanceComparator = (a: Node, b: Node) => {\r\n  const aProps = a.props as DijkstraProps;\r\n  const bProps = b.props as DijkstraProps;\r\n  if (aProps.distance === Infinity && bProps.distance === Infinity) {\r\n    return 0;\r\n  }\r\n  const distanceDifference = aProps.distance - bProps.distance;\r\n  if (distanceDifference !== 0) {\r\n    return distanceDifference;\r\n  }\r\n  return a.position.column - b.position.column;\r\n};\r\n\r\nexport const dijkstra = (\r\n  grid: Node[],\r\n  startPosition: NodePosition,\r\n  endPosition: NodePosition\r\n): Node[] => {\r\n  const visitedNodes: Node[] = [];\r\n  if (!grid || startPosition === endPosition) {\r\n    return visitedNodes;\r\n  }\r\n  grid.forEach((node) => (node.props = { distance: Infinity }));\r\n  //Set start node distance to 0\r\n  setDistance(grid[startPosition.row * NUM_OF_NODES + startPosition.column], 0);\r\n  const priorityQueue = new Heap(nodeDistanceComparator);\r\n  priorityQueue.init(grid);\r\n  const seenIndices = new Set<number>();\r\n  while (!priorityQueue.isEmpty()) {\r\n    const closestNode = priorityQueue.pop();\r\n    if (!closestNode || getDistance(closestNode) === Infinity) {\r\n      break;\r\n    }\r\n    if (isEndNode(closestNode, endPosition)) {\r\n      visitedNodes.push(closestNode);\r\n      break;\r\n    }\r\n    if (closestNode.flags.isWall) {\r\n      continue;\r\n    }\r\n    const index = getIndex(closestNode);\r\n    if (!seenIndices.has(index)) {\r\n      seenIndices.add(index);\r\n      const neighbours = getNeighbours(grid, index);\r\n      neighbours.forEach((neighbour) => {\r\n        const newDistance = getDistance(closestNode) + 1;\r\n        if (newDistance < getDistance(neighbour)) {\r\n          const newNeighbour: Node = JSON.parse(JSON.stringify(neighbour));\r\n          setDistance(newNeighbour, newDistance);\r\n          newNeighbour.parent = closestNode;\r\n          priorityQueue.push(newNeighbour);\r\n        }\r\n      });\r\n      visitedNodes.push(closestNode);\r\n    }\r\n  }\r\n  return visitedNodes;\r\n};\r\n\r\nconst getDistance = (node: Node): number => {\r\n  const props = node.props as DijkstraProps;\r\n  return props.distance;\r\n};\r\n\r\nconst setDistance = (node: Node, distance: number) => {\r\n  const props = node.props as DijkstraProps;\r\n  props.distance = distance;\r\n};\r\n","import Heap from \"heap-js\";\r\nimport { NUM_OF_NODES } from \"../state/constants\";\r\nimport { AStarProps, NodePosition, Node } from \"../types\";\r\nimport { getIndex, isEndNode, getNeighbours } from \"./common\";\r\n\r\nconst nodeFComparator = (a: Node, b: Node) => {\r\n  const aProps = a.props as AStarProps;\r\n  const bProps = b.props as AStarProps;\r\n  if (aProps.f === Infinity && bProps.f === Infinity) {\r\n    return 0;\r\n  }\r\n  const fDifference = aProps.f - bProps.f;\r\n  if (fDifference !== 0) {\r\n    return fDifference;\r\n  }\r\n  return a.position.column - b.position.column;\r\n};\r\n\r\nexport const aStar = (\r\n  grid: Node[],\r\n  startPosition: NodePosition,\r\n  endPosition: NodePosition\r\n): Node[] => {\r\n  const visitedNodes: Node[] = [];\r\n  const seenIndices = new Set<number>();\r\n  if (!grid || startPosition === endPosition) {\r\n    return visitedNodes;\r\n  }\r\n  const startNode =\r\n    grid[startPosition.row * NUM_OF_NODES + startPosition.column];\r\n  const discoveredNodes = new Heap(nodeFComparator);\r\n  discoveredNodes.push(startNode);\r\n  grid.forEach((node) => (node.props = { f: Infinity, g: Infinity }));\r\n  setGScore(startNode, 0);\r\n  setFScore(startNode, manhattanDistance(startNode, endPosition));\r\n  while (!discoveredNodes.isEmpty()) {\r\n    const currentNode = discoveredNodes.pop();\r\n    if (!currentNode) {\r\n      break;\r\n    }\r\n    if (!currentNode || isEndNode(currentNode, endPosition)) {\r\n      visitedNodes.push(currentNode);\r\n      break;\r\n    }\r\n    if (currentNode.flags.isWall) {\r\n      continue;\r\n    }\r\n    const currentProps = currentNode.props as AStarProps;\r\n    const index = getIndex(currentNode);\r\n    if (!seenIndices.has(index)) {\r\n      seenIndices.add(index);\r\n      const neighbours = getNeighbours(grid, index);\r\n      neighbours.forEach((neighbour) => {\r\n        const newScore = currentProps.g + 1;\r\n        if (newScore < getGScore(neighbour)) {\r\n          neighbour.parent = currentNode;\r\n          setGScore(neighbour, newScore);\r\n          setFScore(\r\n            neighbour,\r\n            newScore + manhattanDistance(neighbour, endPosition)\r\n          );\r\n          discoveredNodes.add(neighbour);\r\n        }\r\n      });\r\n    }\r\n    visitedNodes.push(currentNode);\r\n  }\r\n  return visitedNodes;\r\n};\r\n\r\nconst manhattanDistance = (a: Node, endPosition: NodePosition): number => {\r\n  const { row, column } = a.position;\r\n  return (\r\n    Math.abs(row - endPosition.row) + Math.abs(column - endPosition.column)\r\n  );\r\n};\r\n\r\nconst getGScore = (node: Node): number => {\r\n  const props = node.props as AStarProps;\r\n  return props.g;\r\n};\r\n\r\nconst setGScore = (node: Node, value: number) => {\r\n  const props = node.props as AStarProps;\r\n  props.g = value;\r\n};\r\n\r\nconst setFScore = (node: Node, value: number) => {\r\n  const props = node.props as AStarProps;\r\n  props.f = value;\r\n};\r\n","import React, { useEffect } from \"react\";\r\nimport {\r\n  useSetRecoilState,\r\n  useRecoilCallback,\r\n  useRecoilState,\r\n  useRecoilValue,\r\n} from \"recoil\";\r\nimport \"../css/grid.scss\";\r\nimport {\r\n  isDrawingWallsAtom,\r\n  nodeAtom,\r\n  nodeClassesAtom,\r\n  isVisualizedAtom,\r\n  visitedNodesAtom,\r\n  shortestPathNodesAtom,\r\n  selectedAlgorithmAtom,\r\n} from \"../state/atoms\";\r\nimport { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\nimport GridNode from \"./GridNode\";\r\nimport { Algorithm, Node, NodePosition } from \"../types\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport { aStar } from \"../algorithms/astar\";\r\n\r\ninterface GridProps {\r\n  setOnVisualize: (childVisualize: () => void) => void;\r\n  setOnClear: (childClear: () => void) => void;\r\n}\r\n\r\nconst startPositionFuncs: (() => NodePosition)[] = [];\r\nconst endPositionFuncs: (() => NodePosition)[] = [];\r\nconst resetNodeFuncs: (() => void)[] = [];\r\n\r\nconst getShortestPath = (endNode: Node): Node[] => {\r\n  const shortestPath: Node[] = [];\r\n  let node: Node | undefined = endNode;\r\n  while (node) {\r\n    shortestPath.push(node);\r\n    node = node.parent;\r\n  }\r\n  return shortestPath;\r\n};\r\n\r\nconst getArrayIndex = (array: Node[], row: number, column: number): number => {\r\n  return array.length !== 0\r\n    ? array.findIndex(\r\n        (node) => node.position.row === row && node.position.column === column\r\n      )\r\n    : -1;\r\n};\r\n\r\nconst getNodePositionFromChildren = (\r\n  positionFuncs: (() => NodePosition)[]\r\n): NodePosition => {\r\n  let nodePosition = { row: -1, column: -1 };\r\n  for (let positionFunc of positionFuncs) {\r\n    const childPosition = positionFunc();\r\n    if (childPosition) {\r\n      nodePosition = childPosition;\r\n      break;\r\n    }\r\n  }\r\n  return nodePosition;\r\n};\r\n\r\nconst getStartNodePosition = (): NodePosition => {\r\n  return getNodePositionFromChildren(startPositionFuncs);\r\n};\r\n\r\nconst getEndNodePosition = (): NodePosition => {\r\n  return getNodePositionFromChildren(endPositionFuncs);\r\n};\r\n\r\nconst Grid = ({ setOnVisualize, setOnClear }: GridProps) => {\r\n  const setIsStartPosition = (\r\n    childStartPosition: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    startPositionFuncs[childIndex] = childStartPosition;\r\n  };\r\n  const setIsEndPosition = (\r\n    childEndPosition: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    endPositionFuncs[childIndex] = childEndPosition;\r\n  };\r\n  const setResetNode = (\r\n    childResetNode: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    resetNodeFuncs[childIndex] = childResetNode;\r\n  };\r\n  const setIsDrawingWalls = useSetRecoilState(isDrawingWallsAtom);\r\n  const setIsVisualized = useSetRecoilState(isVisualizedAtom);\r\n  const [visitedNodes, setVisitedNodes] = useRecoilState(visitedNodesAtom);\r\n  const [shortestPathNodes, setShortestPathNodes] = useRecoilState(\r\n    shortestPathNodesAtom\r\n  );\r\n  const selectedAlgorithm = useRecoilValue(selectedAlgorithmAtom);\r\n  useEffect(() => {\r\n    setOnVisualize(() => {\r\n      visualizeAlgorithm();\r\n      setIsVisualized(true);\r\n    });\r\n    setOnClear(() => {\r\n      resetNodeFuncs.forEach((resetFunc) => resetFunc());\r\n      resetGridState();\r\n      setVisitedNodes([]);\r\n      setShortestPathNodes([]);\r\n      setIsVisualized(false);\r\n    });\r\n  });\r\n  const getGridState = useRecoilCallback(\r\n    ({ snapshot: { getLoadable } }) =>\r\n      () => {\r\n        let nodes: Node[] = [];\r\n        for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n          for (let j = 0; j < NUM_OF_NODES; j++) {\r\n            const nodeValue = getLoadable(nodeAtom([i, j])).getValue();\r\n            nodes = [...nodes, JSON.parse(JSON.stringify(nodeValue))];\r\n          }\r\n        }\r\n        return nodes;\r\n      }\r\n  );\r\n  const resetGridState = useRecoilCallback(({ reset }) => () => {\r\n    for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n      for (let j = 0; j < NUM_OF_NODES; j++) {\r\n        reset(nodeAtom([i, j]));\r\n        reset(nodeClassesAtom([i, j]));\r\n      }\r\n    }\r\n  });\r\n  const visualizeAlgorithm = () => {\r\n    const startNodePosition = getStartNodePosition();\r\n    const endNodePosition = getEndNodePosition();\r\n    const gridNodes = getGridState();\r\n    let newVisitedNodes: Node[] = [];\r\n    switch (selectedAlgorithm) {\r\n      case Algorithm.Dijkstra:\r\n        newVisitedNodes = dijkstra(\r\n          gridNodes,\r\n          startNodePosition,\r\n          endNodePosition\r\n        );\r\n        break;\r\n      case Algorithm.AStar:\r\n        newVisitedNodes = aStar(gridNodes, startNodePosition, endNodePosition);\r\n        break;\r\n    }\r\n    const endNode = newVisitedNodes[newVisitedNodes.length - 1];\r\n    if (\r\n      endNode.position.row === endNodePosition.row &&\r\n      endNode.position.column === endNodePosition.column\r\n    ) {\r\n      setShortestPathNodes(getShortestPath(endNode));\r\n    }\r\n    setVisitedNodes(newVisitedNodes);\r\n  };\r\n  return (\r\n    <div\r\n      className=\"grid\"\r\n      onMouseDown={() => setIsDrawingWalls(true)}\r\n      onMouseUp={() => setIsDrawingWalls(false)}\r\n    >\r\n      {Array.from(Array(NUM_OF_ROWS * NUM_OF_NODES).keys()).map((index) => {\r\n        const row = Math.floor(index / NUM_OF_NODES);\r\n        const column = index % NUM_OF_NODES;\r\n        return (\r\n          <GridNode\r\n            position={{ row, column }}\r\n            visitedNumber={getArrayIndex(visitedNodes, row, column)}\r\n            visitedCount={visitedNodes.length}\r\n            pathNumber={getArrayIndex(\r\n              shortestPathNodes.slice().reverse(),\r\n              row,\r\n              column\r\n            )}\r\n            setIsStartPosition={setIsStartPosition}\r\n            setIsEndPosition={setIsEndPosition}\r\n            setResetNode={setResetNode}\r\n            key={index}\r\n          ></GridNode>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import React from \"react\";\r\nimport Button from \"@mui/material/Button\";\r\nimport Box from \"@mui/material/Box\";\r\nimport FormControl from \"@mui/material/FormControl\";\r\nimport InputLabel from \"@mui/material/InputLabel\";\r\nimport Select, { SelectChangeEvent } from \"@mui/material/Select\";\r\nimport MenuItem from \"@mui/material/MenuItem\";\r\nimport { useRecoilState } from \"recoil\";\r\nimport { selectedAlgorithmAtom } from \"../state/atoms\";\r\nimport { Algorithm } from \"../types\";\r\n\r\ninterface ControlsProps {\r\n  visualizeGrid: () => void;\r\n  resetGrid: () => void;\r\n}\r\n\r\nconst Controls = ({ visualizeGrid, resetGrid }: ControlsProps) => {\r\n  const [selectedAlgorithm, setSelectedAlgorithm] = useRecoilState(\r\n    selectedAlgorithmAtom\r\n  );\r\n  const handleAlgorithmChange = (event: SelectChangeEvent<string>) => {\r\n    setSelectedAlgorithm(event.target.value);\r\n  };\r\n  return (\r\n    <div>\r\n      <Box>\r\n        <FormControl fullWidth>\r\n          <InputLabel id=\"selectedAlgorithmLabel\">Algorithm</InputLabel>\r\n          <Select\r\n            labelId=\"selectedAlgorithmLabel\"\r\n            value={selectedAlgorithm}\r\n            label=\"Algorithm\"\r\n            onChange={handleAlgorithmChange}\r\n            defaultValue={Algorithm.Dijkstra}\r\n          >\r\n            <MenuItem value={Algorithm.Dijkstra}>Dijkstra</MenuItem>\r\n            <MenuItem value={Algorithm.AStar}>A*</MenuItem>\r\n          </Select>\r\n        </FormControl>\r\n        <Button sx={{ m: 5 }} variant=\"contained\" onClick={visualizeGrid}>\r\n          Visualize!\r\n        </Button>\r\n        <Button sx={{ m: 5 }} variant=\"contained\" onClick={resetGrid}>\r\n          Reset grid\r\n        </Button>\r\n      </Box>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Controls;\r\n","import React from \"react\";\r\nimport Grid from \"./Grid\";\r\nimport Controls from \"./Controls\";\r\nimport \"../css/app.scss\";\r\n\r\nlet visualizeGrid: () => void = () => {};\r\nlet resetGrid: () => void = () => {};\r\n\r\nconst App = () => {\r\n  const setOnVisualize = (childVisualize: () => void) => {\r\n    visualizeGrid = childVisualize;\r\n  };\r\n  const setOnClear = (childClear: () => void) => {\r\n    resetGrid = childClear;\r\n  };\r\n  return (\r\n    <div className=\"container\">\r\n      <Controls\r\n        visualizeGrid={() => visualizeGrid()}\r\n        resetGrid={() => resetGrid()}\r\n      ></Controls>\r\n      <Grid setOnVisualize={setOnVisualize} setOnClear={setOnClear}></Grid>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { RecoilRoot } from \"recoil\";\r\nimport \"./css/index.scss\";\r\nimport App from \"./components/App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <RecoilRoot>\r\n      <App />\r\n    </RecoilRoot>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}