{"version":3,"sources":["types.ts","state/constants.ts","state/atoms.ts","patterns/recursive.ts","algorithms/common.ts","hooks.ts","state/selectors.ts","components/GridNode.tsx","algorithms/dijkstra.ts","algorithms/astar.ts","components/Grid.tsx","components/menu/AlgorithmMenu.tsx","components/menu/PatternMenu.tsx","patterns/random.ts","components/drawer/SpeedSelection.tsx","components/drawer/WeightNodeRow.tsx","components/drawer/WeightNodeSelection.tsx","components/drawer/DrawingModeSelection.tsx","components/drawer/WeightNodeForm.tsx","components/drawer/ConfigurationDrawer.tsx","components/Controls.tsx","components/App.tsx","index.tsx"],"names":["Algorithm","VisualizationSpeed","DrawingMode","NUM_OF_ROWS","NUM_OF_NODES","DEFAULT_WEIGHT_NODES","weight","color","CutDirection","WallDirection","isVisualizedAtom","atom","key","default","isMovingStartAtom","isMovingEndAtom","nodeAtom","atomFamily","row","column","position","flags","isWall","isVisited","isPath","isStart","isEnd","weightProps","createNode","visitedNodesAtom","shortestPathNodesAtom","selectedAlgorithmAtom","Dijkstra","visualizationSpeedAtom","Medium","drawingModeAtom","Wall","selectedWeightNodeAtom","weightNodesAtom","getIndex","isEndNode","node","endPosition","getNeighbours","grid","index","neighbours","push","useTimeout","callback","delay","savedCallback","useRef","useEffect","current","id","setTimeout","clearTimeout","nodeClassesSelector","selectorFamily","get","classes","GridNode","visitedNumber","pathNumber","visitedCount","setIsStartPosition","setIsEndPosition","setClearNode","isVisualized","useRecoilValue","visualizationSpeed","drawingMode","selectedWeightNode","useRecoilState","isMovingStart","setIsMovingStart","isMovingEnd","setIsMovingEnd","setNode","nodeClasses","isStartPosition","undefined","isEndPosition","clearNode","setIsStart","setIsEnd","ReactDOM","unstable_batchedUpdates","getVisitedNodeDelay","getPathNodeDelay","resetStart","useRecoilCallback","reset","resetEnd","drawNode","Infinity","length","document","documentElement","style","setProperty","styles","filter","className","onMouseOver","e","preventDefault","isLeftMouseButtonPressed","buttons","onMouseDown","onMouseLeave","onMouseUp","nodeDistanceComparator","a","b","aProps","props","bProps","distance","distanceDifference","getDistance","setDistance","nodeFComparator","f","fDifference","g","manhattanDistance","Math","abs","getGScore","setGScore","value","setFScore","startPositionFuncs","endPositionFuncs","clearNodeFuncs","getArrayIndex","array","findIndex","getNodePositionFromChildren","positionFuncs","nodePosition","childPosition","positionFunc","Grid","setOnVisualize","setOnReset","setOnClearPath","childStartPosition","childIndex","childEndPosition","childClearNode","setIsVisualized","useSetRecoilState","visitedNodes","setVisitedNodes","shortestPathNodes","setShortestPathNodes","selectedAlgorithm","visualizeAlgorithm","resetGridState","forEach","clearFunc","getGridState","getLoadable","snapshot","nodes","i","j","nodeValue","getValue","JSON","parse","stringify","startNodePosition","endNodePosition","gridNodes","newVisitedNodes","startPosition","priorityQueue","Heap","init","seenIndices","Set","closestNode","pop","has","add","neighbour","newDistance","newNeighbour","parent","isEmpty","dijkstra","AStar","startNode","discoveredNodes","currentNode","currentProps","newScore","aStar","endNode","shortestPath","getShortestPath","Array","from","keys","map","floor","slice","reverse","AlgorithmMenu","setSelectedAlgorithm","useState","menuAnchorElement","setMenuAnchorElement","open","Boolean","handleAlgorithmChange","event","currentTarget","dataset","myValue","Button","sx","mx","backgroundColor","size","endIcon","onClick","Menu","anchorEl","onClose","MenuItem","divideBox","x","y","width","height","halfResolutionGrid","isHorizontal","chooseDirection","HORIZONTAL","wallX","getRandomInt","wallY","holeX","holeY","dx","dy","wallLength","wallDirection","S","E","VERTICAL","maxExclusive","random","getOuterWallNodes","getNode","outerRows","outerColumns","outerWallNodes","rowIdx","columnIdx","PatternMenu","isDisabled","generateRandomMaze","set","wallNodes","getRandomPatternWalls","wallNode","generateRecursiveDivisionMaze","apply","rowElem","getRecursiveDivisionWallNodes","sort","disabled","SpeedSelection","setVisualizationSpeed","FormControl","ml","FormLabel","fontWeight","mt","RadioGroup","onChange","Number","target","Object","speed","isNaN","FormControlLabel","control","Radio","label","WeightNodeRow","display","alignItems","mr","border","justifyContent","WeightNodeSelection","weightNodes","setSelectedWeightNode","flex","newWeightNode","find","weightNode","DrawingModeSelection","setDrawingMode","Weighted","mode","DEFAULT_COLOR","createColor","WeightNodeForm","setWeightNodes","setColor","setWeight","flexDirection","margin","flexWrap","TextField","inputProps","inputMode","pattern","newValue","hideTextfield","IconButton","p","hex","ConfigurationDrawer","setOpen","toggleDrawer","newOpen","type","Fragment","Drawer","anchor","PaperProps","backgroundImage","Divider","Controls","visualizeGrid","resetGrid","clearPath","AppBar","mb","Toolbar","variant","Typography","fontFamily","Box","transform","App","childVisualize","childReset","childClearPath","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.28dc40d8.chunk.js","sourcesContent":["import {\r\n  FAST_NODE_UPDATE_SPEED,\r\n  MEDIUM_NODE_UPDATE_SPEED,\r\n  SLOW_NODE_UPDATE_SPEED,\r\n} from \"./state/constants\";\r\n\r\nexport type VoidFunction = () => void;\r\nexport type GetNodeFunction = (i: number, j: number) => Node;\r\n\r\nexport interface Node {\r\n  position: NodePosition;\r\n  flags: NodeFlags;\r\n  weightProps: WeightNode;\r\n  parent?: Node;\r\n  props?: any;\r\n}\r\n\r\nexport interface WeightNode {\r\n  weight: number;\r\n  color: string;\r\n}\r\n\r\nexport interface DijkstraProps {\r\n  distance: number;\r\n}\r\n\r\nexport interface AStarProps {\r\n  f: number;\r\n  g: number;\r\n}\r\n\r\nexport interface NodePosition {\r\n  row: number;\r\n  column: number;\r\n}\r\n\r\nexport interface NodeFlags {\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  isPath: boolean;\r\n  isStart: boolean;\r\n  isEnd: boolean;\r\n}\r\n\r\nexport enum Algorithm {\r\n  Dijkstra = \"Dijkstra\",\r\n  AStar = \"A*\",\r\n}\r\n\r\nexport enum VisualizationSpeed {\r\n  Fast = FAST_NODE_UPDATE_SPEED,\r\n  Medium = MEDIUM_NODE_UPDATE_SPEED,\r\n  Slow = SLOW_NODE_UPDATE_SPEED,\r\n}\r\n\r\nexport enum DrawingMode {\r\n  Wall = \"Wall\",\r\n  Weighted = \"Weighted\",\r\n}\r\n","import { WeightNode } from \"../types\";\r\n\r\nexport const NUM_OF_ROWS = 19;\r\nexport const NUM_OF_NODES = 49;\r\n\r\nexport const DEFAULT_START_ROW = 10;\r\nexport const DEFAULT_START_COLUMN = 5;\r\nexport const DEFAULT_END_ROW = 10;\r\nexport const DEFAULT_END_COLUMN = 45;\r\n\r\nexport const FAST_NODE_UPDATE_SPEED = 4;\r\nexport const MEDIUM_NODE_UPDATE_SPEED = 10;\r\nexport const SLOW_NODE_UPDATE_SPEED = 25;\r\n\r\nexport const DEFAULT_WEIGHT_NODES: WeightNode[] = [\r\n  { weight: 5, color: \"#ffff00\" },\r\n  { weight: 10, color: \"#ff0000\" },\r\n];\r\n","import { atom, atomFamily } from \"recoil\";\r\nimport {\r\n  Algorithm,\r\n  DrawingMode,\r\n  Node,\r\n  VisualizationSpeed,\r\n  WeightNode,\r\n} from \"../types\";\r\nimport {\r\n  DEFAULT_END_COLUMN,\r\n  DEFAULT_END_ROW,\r\n  DEFAULT_START_COLUMN,\r\n  DEFAULT_START_ROW,\r\n  DEFAULT_WEIGHT_NODES,\r\n} from \"./constants\";\r\n\r\nconst createNode = (row: number, column: number): Node => {\r\n  return {\r\n    position: {\r\n      row,\r\n      column,\r\n    },\r\n    flags: {\r\n      isWall: false,\r\n      isVisited: false,\r\n      isPath: false,\r\n      isStart: row === DEFAULT_START_ROW && column === DEFAULT_START_COLUMN,\r\n      isEnd: row === DEFAULT_END_ROW && column === DEFAULT_END_COLUMN,\r\n    },\r\n    weightProps: {\r\n      weight: 1,\r\n      color: \"\",\r\n    },\r\n  };\r\n};\r\n\r\nexport const isVisualizedAtom = atom<boolean>({\r\n  key: \"isVisualized\",\r\n  default: false,\r\n});\r\n\r\nexport const isMovingStartAtom = atom<boolean>({\r\n  key: \"isMovingStart\",\r\n  default: false,\r\n});\r\n\r\nexport const isMovingEndAtom = atom<boolean>({\r\n  key: \"isMovingEnd\",\r\n  default: false,\r\n});\r\n\r\nexport const nodeAtom = atomFamily<Node, number[]>({\r\n  key: \"grid\",\r\n  default: ([row, column]) => createNode(row, column),\r\n});\r\n\r\nexport const visitedNodesAtom = atom<Node[]>({\r\n  key: \"visitedNodes\",\r\n  default: [],\r\n});\r\n\r\nexport const shortestPathNodesAtom = atom<Node[]>({\r\n  key: \"shortestPathNodes\",\r\n  default: [],\r\n});\r\n\r\nexport const selectedAlgorithmAtom = atom<string>({\r\n  key: \"selectedAlgorithm\",\r\n  default: Algorithm.Dijkstra,\r\n});\r\n\r\nexport const visualizationSpeedAtom = atom<VisualizationSpeed>({\r\n  key: \"visualizationSpeed\",\r\n  default: VisualizationSpeed.Medium,\r\n});\r\n\r\nexport const drawingModeAtom = atom<DrawingMode>({\r\n  key: \"drawingMode\",\r\n  default: DrawingMode.Wall,\r\n});\r\n\r\nexport const selectedWeightNodeAtom = atom<WeightNode>({\r\n  key: \"selectedWeightNode\",\r\n  default: DEFAULT_WEIGHT_NODES[0],\r\n});\r\n\r\nexport const weightNodesAtom = atom<WeightNode[]>({\r\n  key: \"weightNodes\",\r\n  default: DEFAULT_WEIGHT_NODES,\r\n});\r\n","import { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\nimport { Node, GetNodeFunction } from \"../types\";\r\n\r\nenum CutDirection {\r\n  HORIZONTAL = 0,\r\n  VERTICAL,\r\n}\r\n\r\nenum WallDirection {\r\n  S = 1,\r\n  E,\r\n}\r\n\r\nexport const getRecursiveDivisionWallNodes = (\r\n  getNode: GetNodeFunction\r\n): Node[] => {\r\n  let wallNodes: Node[] = [];\r\n  wallNodes = [...wallNodes, ...getOuterWallNodes(getNode)];\r\n  const halfResolutionGrid: number[][] = Array.apply(\r\n    null,\r\n    Array((NUM_OF_ROWS + 1) / 2)\r\n  ).map(() => {\r\n    return Array.apply(null, Array((NUM_OF_NODES + 1) / 2)).map(() => {\r\n      return 0;\r\n    });\r\n  });\r\n  divideBox(\r\n    0,\r\n    0,\r\n    (NUM_OF_NODES + 1) / 2,\r\n    (NUM_OF_ROWS + 1) / 2,\r\n    halfResolutionGrid\r\n  );\r\n  halfResolutionGrid.forEach((row, x) => {\r\n    row.forEach((rowElem, y) => {\r\n      wallNodes.push(getNode(2 * x, 2 * y));\r\n      if ((rowElem & WallDirection.S) !== 0) {\r\n        wallNodes.push(getNode(2 * (x + 1), 2 * y + 1));\r\n      }\r\n      if ((rowElem & WallDirection.E) !== 0) {\r\n        wallNodes.push(getNode(2 * x + 1, 2 * (y + 1)));\r\n      }\r\n    });\r\n  });\r\n  return wallNodes;\r\n};\r\n\r\nconst divideBox = (\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n  halfResolutionGrid: number[][]\r\n) => {\r\n  if (width <= 2 || height <= 2) {\r\n    return;\r\n  }\r\n  const direction = chooseDirection(width, height);\r\n  const isHorizontal = direction === CutDirection.HORIZONTAL;\r\n  //Choose where to draw the wall from\r\n  let wallX = x + (isHorizontal ? 0 : getRandomInt(width - 2));\r\n  let wallY = y + (isHorizontal ? getRandomInt(height - 2) : 0);\r\n\r\n  //Choose where the hole in the wall is\r\n  const holeX = wallX + (isHorizontal ? getRandomInt(width) : 0);\r\n  const holeY = wallY + (isHorizontal ? 0 : getRandomInt(height));\r\n\r\n  //Helper values\r\n  const dx = isHorizontal ? 1 : 0;\r\n  const dy = isHorizontal ? 0 : 1;\r\n  const wallLength = isHorizontal ? width : height;\r\n  const wallDirection = isHorizontal ? WallDirection.S : WallDirection.E;\r\n  //Draw walls\r\n  for (let i = 0; i < wallLength; i++) {\r\n    if (wallY !== holeY || wallX !== holeX) {\r\n      halfResolutionGrid[wallY][wallX] |= wallDirection;\r\n    }\r\n    wallX += dx;\r\n    wallY += dy;\r\n  }\r\n  //Recursion\r\n  if (isHorizontal) {\r\n    divideBox(x, y, width, wallY - y + 1, halfResolutionGrid);\r\n    divideBox(x, wallY + 1, width, y + height - wallY - 1, halfResolutionGrid);\r\n  } else {\r\n    divideBox(x, y, wallX - x + 1, height, halfResolutionGrid);\r\n    divideBox(wallX + 1, y, x + width - wallX - 1, height, halfResolutionGrid);\r\n  }\r\n};\r\n\r\nconst chooseDirection = (width: number, height: number): CutDirection => {\r\n  if (width <= height) {\r\n    return CutDirection.HORIZONTAL;\r\n  }\r\n  return CutDirection.VERTICAL;\r\n};\r\n\r\nconst getRandomInt = (maxExclusive: number) => {\r\n  return Math.floor(Math.random() * maxExclusive);\r\n};\r\n\r\nconst getOuterWallNodes = (getNode: GetNodeFunction): Node[] => {\r\n  const outerRows = [0, NUM_OF_ROWS - 1];\r\n  const outerColumns = [0, NUM_OF_NODES - 1];\r\n  const outerWallNodes: Node[] = [];\r\n  for (const rowIdx in outerRows) {\r\n    const row = outerRows[rowIdx];\r\n    for (let i = 0; i < NUM_OF_NODES; i++) {\r\n      outerWallNodes.push(getNode(row, i));\r\n    }\r\n  }\r\n  for (const columnIdx in outerColumns) {\r\n    const column = outerColumns[columnIdx];\r\n    for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n      outerWallNodes.push(getNode(i, column));\r\n    }\r\n  }\r\n  return outerWallNodes;\r\n};\r\n","import { Node, NodePosition } from \"../types\";\r\nimport { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\n\r\nexport const getIndex = ({ position: { row, column } }: Node): number => {\r\n  return row * NUM_OF_NODES + column;\r\n};\r\n\r\nexport const isEndNode = (node: Node, endPosition: NodePosition): boolean => {\r\n  return (\r\n    node.position.row === endPosition.row &&\r\n    node.position.column === endPosition.column\r\n  );\r\n};\r\n\r\nexport const getNeighbours = (grid: Node[], index: number): Node[] => {\r\n  const neighbours: Node[] = [];\r\n  if (index % NUM_OF_NODES !== NUM_OF_NODES - 1) {\r\n    neighbours.push(grid[index + 1]);\r\n  }\r\n  if (index % NUM_OF_NODES !== 0) {\r\n    neighbours.push(grid[index - 1]);\r\n  }\r\n  if (index >= NUM_OF_NODES) {\r\n    neighbours.push(grid[index - NUM_OF_NODES]);\r\n  }\r\n  if (index < NUM_OF_NODES * (NUM_OF_ROWS - 1)) {\r\n    neighbours.push(grid[index + NUM_OF_NODES]);\r\n  }\r\n  return neighbours;\r\n};\r\n","import { useRef, useEffect } from \"react\";\r\nimport { VoidFunction } from \"./types\";\r\n\r\nexport const useTimeout = (callback: VoidFunction, delay: number) => {\r\n  const savedCallback = useRef<VoidFunction>();\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  });\r\n  useEffect(() => {\r\n    const tick = () => {\r\n      if (savedCallback.current) {\r\n        savedCallback.current();\r\n      }\r\n    };\r\n    const id = setTimeout(tick, delay);\r\n    return () => clearTimeout(id);\r\n  }, [delay]);\r\n};\r\n","import { selectorFamily } from \"recoil\";\r\nimport { nodeAtom } from \"./atoms\";\r\n\r\nconst WALL_CLASS = \" wall\";\r\nconst VISITED_CLASS = \" visited\";\r\nconst PATH_CLASS = \" path\";\r\nconst ANIMATION_CLASS = \" node-animation\";\r\nconst WEIGHT_CLASS = \" weight-node\";\r\n\r\nexport const nodeClassesSelector = selectorFamily<string, number[]>({\r\n  key: \"nodeClasses\",\r\n  get:\r\n    ([row, column]) =>\r\n    ({ get }) => {\r\n      const node = get(nodeAtom([row, column]));\r\n      const { isWall, isVisited, isPath } = node.flags;\r\n      const { weight } = node.weightProps;\r\n      let classes = \"node\";\r\n      classes += isWall ? WALL_CLASS : \"\";\r\n      classes += isVisited ? VISITED_CLASS : \"\";\r\n      classes += isPath ? PATH_CLASS : \"\";\r\n      classes += weight > 1 ? WEIGHT_CLASS : \"\";\r\n      classes += isWall || isVisited || weight > 1 ? ANIMATION_CLASS : \"\";\r\n      return classes;\r\n    },\r\n});\r\n","import React, { useEffect, useState } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { VscDebugStart } from \"react-icons/vsc\";\r\nimport { FaMapMarkerAlt } from \"react-icons/fa\";\r\nimport { useRecoilCallback, useRecoilState, useRecoilValue } from \"recoil\";\r\nimport \"../css/gridNode.scss\";\r\nimport {\r\n  isMovingStartAtom,\r\n  isMovingEndAtom,\r\n  isVisualizedAtom,\r\n  nodeAtom,\r\n  visualizationSpeedAtom,\r\n  drawingModeAtom,\r\n  selectedWeightNodeAtom,\r\n} from \"../state/atoms\";\r\nimport { DrawingMode, NodePosition, VoidFunction } from \"../types\";\r\nimport { getIndex } from \"../algorithms/common\";\r\nimport { useTimeout } from \"../hooks\";\r\nimport { nodeClassesSelector } from \"../state/selectors\";\r\nimport {\r\n  DEFAULT_END_COLUMN,\r\n  DEFAULT_END_ROW,\r\n  DEFAULT_START_COLUMN,\r\n  DEFAULT_START_ROW,\r\n} from \"../state/constants\";\r\n\r\ninterface NodeProps {\r\n  position: NodePosition;\r\n  visitedNumber: number;\r\n  visitedCount: number;\r\n  pathNumber: number;\r\n  setIsStartPosition: any;\r\n  setIsEndPosition: any;\r\n  setClearNode: (childClearNode: VoidFunction, index: number) => void;\r\n}\r\n\r\nconst getPathNodeDelay = (\r\n  visualizationSpeed: number,\r\n  visitedCount: number,\r\n  pathNumber: number\r\n): number => {\r\n  return visualizationSpeed * (visitedCount + 2 * (pathNumber + 1));\r\n};\r\n\r\nconst getVisitedNodeDelay = (\r\n  visualizationSpeed: number,\r\n  visitedNumber: number\r\n) => {\r\n  return visualizationSpeed * (visitedNumber + 1);\r\n};\r\n\r\nconst GridNode = ({\r\n  position: { row, column },\r\n  visitedNumber,\r\n  pathNumber,\r\n  visitedCount,\r\n  setIsStartPosition,\r\n  setIsEndPosition,\r\n  setClearNode,\r\n}: NodeProps) => {\r\n  const isVisualized = useRecoilValue(isVisualizedAtom);\r\n  const visualizationSpeed = useRecoilValue(visualizationSpeedAtom);\r\n  const drawingMode = useRecoilValue(drawingModeAtom);\r\n  const selectedWeightNode = useRecoilValue(selectedWeightNodeAtom);\r\n  const [isMovingStart, setIsMovingStart] = useRecoilState(isMovingStartAtom);\r\n  const [isMovingEnd, setIsMovingEnd] = useRecoilState(isMovingEndAtom);\r\n  const [node, setNode] = useRecoilState(nodeAtom([row, column]));\r\n  const nodeClasses = useRecoilValue<string>(\r\n    nodeClassesSelector([row, column])\r\n  );\r\n  const isStartPosition = () => {\r\n    return node.flags.isStart ? { row, column } : undefined;\r\n  };\r\n  const isEndPosition = () => {\r\n    return node.flags.isEnd ? { row, column } : undefined;\r\n  };\r\n  const clearNode = () => {\r\n    setNode({\r\n      ...node,\r\n      flags: {\r\n        ...node.flags,\r\n        isVisited: false,\r\n        isPath: false,\r\n      },\r\n    });\r\n  };\r\n  const setIsStart = (isStart: boolean) => {\r\n    setNode({\r\n      ...node,\r\n      flags: {\r\n        ...node.flags,\r\n        isStart,\r\n      },\r\n    });\r\n  };\r\n  const setIsEnd = (isEnd: boolean) => {\r\n    setNode({\r\n      ...node,\r\n      flags: {\r\n        ...node.flags,\r\n        isEnd,\r\n      },\r\n    });\r\n  };\r\n  useEffect(() => {\r\n    setIsStartPosition(isStartPosition, getIndex(node));\r\n    setIsEndPosition(isEndPosition, getIndex(node));\r\n    setClearNode(clearNode, getIndex(node));\r\n  });\r\n  useTimeout(() => {\r\n    if (visitedNumber !== -1 && !node.flags.isVisited) {\r\n      ReactDOM.unstable_batchedUpdates(() => {\r\n        setNode({\r\n          ...node,\r\n          flags: {\r\n            ...node.flags,\r\n            isVisited: true,\r\n          },\r\n        });\r\n      });\r\n    }\r\n  }, getVisitedNodeDelay(visualizationSpeed, visitedNumber));\r\n\r\n  useTimeout(() => {\r\n    if (pathNumber !== -1) {\r\n      setNode({\r\n        ...node,\r\n        flags: {\r\n          ...node.flags,\r\n          isPath: true,\r\n        },\r\n      });\r\n    }\r\n  }, getPathNodeDelay(visualizationSpeed, visitedCount, pathNumber));\r\n\r\n  const handleMouseOver = (e: React.MouseEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    const isLeftMouseButtonPressed = e.buttons === 1;\r\n    const { isWall } = node.flags;\r\n    if (!isWall && isMovingStart) {\r\n      setIsStart(true);\r\n    } else if (!isWall && isMovingEnd) {\r\n      setIsEnd(true);\r\n    } else if (isLeftMouseButtonPressed && !isMovingStart && !isMovingEnd) {\r\n      drawNode();\r\n    }\r\n  };\r\n\r\n  const handleMouseDown = (e: React.MouseEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    const { isStart, isEnd } = node.flags;\r\n    if (isStart && !isVisualized) {\r\n      setIsMovingStart(true);\r\n    } else if (isEnd && !isVisualized) {\r\n      setIsMovingEnd(true);\r\n    } else {\r\n      drawNode();\r\n    }\r\n  };\r\n\r\n  const handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    const { isStart, isEnd } = node.flags;\r\n    if (isStart && isMovingStart) {\r\n      setIsStart(false);\r\n    } else if (isEnd && isMovingEnd) {\r\n      setIsEnd(false);\r\n    }\r\n  };\r\n\r\n  const resetStart = useRecoilCallback(({ reset }) => () => {\r\n    reset(nodeAtom([DEFAULT_START_ROW, DEFAULT_START_COLUMN]));\r\n  });\r\n\r\n  const resetEnd = useRecoilCallback(({ reset }) => () => {\r\n    reset(nodeAtom([DEFAULT_END_ROW, DEFAULT_END_COLUMN]));\r\n  });\r\n\r\n  const handleMouseUp = (e: React.MouseEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    const { isWall } = node.flags;\r\n    if (isWall) {\r\n      if (isMovingStart) {\r\n        setIsStart(false);\r\n        resetStart();\r\n      } else if (isMovingEnd) {\r\n        setIsEnd(false);\r\n        resetEnd();\r\n      }\r\n    }\r\n    setIsMovingStart(false);\r\n    setIsMovingEnd(false);\r\n  };\r\n\r\n  const drawNode = () => {\r\n    if (!isVisualized) {\r\n      if (drawingMode === DrawingMode.Wall) {\r\n        setNode({\r\n          ...node,\r\n          flags: {\r\n            ...node.flags,\r\n            isWall: !node.flags.isWall,\r\n          },\r\n          weightProps: {\r\n            weight: Infinity,\r\n            color: \"\",\r\n          },\r\n        });\r\n      } else {\r\n        setNode({\r\n          ...node,\r\n          flags: {\r\n            ...node.flags,\r\n            isWall: false,\r\n          },\r\n          weightProps: {\r\n            weight: selectedWeightNode.weight,\r\n            color: selectedWeightNode.color,\r\n          },\r\n        });\r\n      }\r\n    }\r\n  };\r\n  if (node.weightProps.color.length !== 0) {\r\n    document.documentElement.style.setProperty(\r\n      \"--weight-node-color\",\r\n      node.weightProps.color\r\n    );\r\n  }\r\n\r\n  const styles: React.CSSProperties = {\r\n    filter:\r\n      node.flags.isVisited && node.weightProps.color.length !== 0\r\n        ? \"brightness(0.7)\"\r\n        : \"brightness(1)\",\r\n  };\r\n  return (\r\n    <div\r\n      className={nodeClasses}\r\n      style={styles}\r\n      onMouseOver={handleMouseOver}\r\n      onMouseDown={handleMouseDown}\r\n      onMouseLeave={handleMouseLeave}\r\n      onMouseUp={handleMouseUp}\r\n    >\r\n      {node.flags.isStart && <VscDebugStart className=\"icon\" />}\r\n      {node.flags.isEnd && <FaMapMarkerAlt className=\"icon\" />}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GridNode;\r\n","import Heap from \"heap-js\";\r\nimport { NUM_OF_NODES } from \"../state/constants\";\r\nimport { DijkstraProps, Node, NodePosition } from \"../types\";\r\nimport { getIndex, isEndNode, getNeighbours } from \"./common\";\r\n\r\nconst nodeDistanceComparator = (a: Node, b: Node) => {\r\n  const aProps = a.props as DijkstraProps;\r\n  const bProps = b.props as DijkstraProps;\r\n  if (aProps.distance === Infinity && bProps.distance === Infinity) {\r\n    return 0;\r\n  }\r\n  const distanceDifference = aProps.distance - bProps.distance;\r\n  if (distanceDifference !== 0) {\r\n    return distanceDifference;\r\n  }\r\n  return a.position.row - b.position.row;\r\n};\r\n\r\nexport const dijkstra = (\r\n  grid: Node[],\r\n  startPosition: NodePosition,\r\n  endPosition: NodePosition\r\n): Node[] => {\r\n  const visitedNodes: Node[] = [];\r\n  if (!grid || startPosition === endPosition) {\r\n    return visitedNodes;\r\n  }\r\n  grid.forEach((node) => (node.props = { distance: Infinity }));\r\n  //Set start node distance to 0\r\n  setDistance(grid[startPosition.row * NUM_OF_NODES + startPosition.column], 0);\r\n  const priorityQueue = new Heap(nodeDistanceComparator);\r\n  priorityQueue.init(grid);\r\n  const seenIndices = new Set<number>();\r\n  while (!priorityQueue.isEmpty()) {\r\n    const closestNode = priorityQueue.pop();\r\n    if (!closestNode || getDistance(closestNode) === Infinity) {\r\n      break;\r\n    }\r\n    if (isEndNode(closestNode, endPosition)) {\r\n      visitedNodes.push(closestNode);\r\n      break;\r\n    }\r\n    if (closestNode.flags.isWall) {\r\n      continue;\r\n    }\r\n    const index = getIndex(closestNode);\r\n    if (!seenIndices.has(index)) {\r\n      seenIndices.add(index);\r\n      const neighbours = getNeighbours(grid, index);\r\n      neighbours.forEach((neighbour) => {\r\n        const newDistance =\r\n          getDistance(closestNode) + closestNode.weightProps.weight;\r\n        if (newDistance < getDistance(neighbour)) {\r\n          const newNeighbour: Node = JSON.parse(JSON.stringify(neighbour));\r\n          setDistance(newNeighbour, newDistance);\r\n          newNeighbour.parent = closestNode;\r\n          priorityQueue.push(newNeighbour);\r\n        }\r\n      });\r\n      visitedNodes.push(closestNode);\r\n    }\r\n  }\r\n  return visitedNodes;\r\n};\r\n\r\nconst getDistance = (node: Node): number => {\r\n  const props = node.props as DijkstraProps;\r\n  return props.distance;\r\n};\r\n\r\nconst setDistance = (node: Node, distance: number) => {\r\n  const props = node.props as DijkstraProps;\r\n  props.distance = distance;\r\n};\r\n","import Heap from \"heap-js\";\r\nimport { NUM_OF_NODES } from \"../state/constants\";\r\nimport { AStarProps, NodePosition, Node } from \"../types\";\r\nimport { getIndex, isEndNode, getNeighbours } from \"./common\";\r\n\r\nconst nodeFComparator = (a: Node, b: Node) => {\r\n  const aProps = a.props as AStarProps;\r\n  const bProps = b.props as AStarProps;\r\n  if (aProps.f === Infinity && bProps.f === Infinity) {\r\n    return 0;\r\n  }\r\n  const fDifference = aProps.f - bProps.f;\r\n  if (fDifference !== 0) {\r\n    return fDifference;\r\n  }\r\n  return a.props.f - a.props.g - 1 - (b.props.f - b.props.g - 1);\r\n};\r\n\r\nexport const aStar = (\r\n  grid: Node[],\r\n  startPosition: NodePosition,\r\n  endPosition: NodePosition\r\n): Node[] => {\r\n  const visitedNodes: Node[] = [];\r\n  const seenIndices = new Set<number>();\r\n  if (!grid || startPosition === endPosition) {\r\n    return visitedNodes;\r\n  }\r\n  const startNode =\r\n    grid[startPosition.row * NUM_OF_NODES + startPosition.column];\r\n  const discoveredNodes = new Heap(nodeFComparator);\r\n  discoveredNodes.push(startNode);\r\n  grid.forEach((node) => (node.props = { f: Infinity, g: Infinity }));\r\n  setGScore(startNode, 0);\r\n  setFScore(startNode, manhattanDistance(startNode, endPosition));\r\n  while (!discoveredNodes.isEmpty()) {\r\n    const currentNode = discoveredNodes.pop();\r\n    if (!currentNode) {\r\n      break;\r\n    }\r\n    if (!currentNode || isEndNode(currentNode, endPosition)) {\r\n      visitedNodes.push(currentNode);\r\n      break;\r\n    }\r\n    if (currentNode.flags.isWall) {\r\n      continue;\r\n    }\r\n    const currentProps = currentNode.props as AStarProps;\r\n    const index = getIndex(currentNode);\r\n    if (!seenIndices.has(index)) {\r\n      seenIndices.add(index);\r\n      const neighbours = getNeighbours(grid, index);\r\n      neighbours.forEach((neighbour) => {\r\n        const newScore = currentProps.g + neighbour.weightProps.weight;\r\n        if (newScore < getGScore(neighbour)) {\r\n          neighbour.parent = currentNode;\r\n          setGScore(neighbour, newScore);\r\n          setFScore(\r\n            neighbour,\r\n            newScore + manhattanDistance(neighbour, endPosition)\r\n          );\r\n          discoveredNodes.add(neighbour);\r\n        }\r\n      });\r\n    }\r\n    visitedNodes.push(currentNode);\r\n  }\r\n  return visitedNodes;\r\n};\r\n\r\nconst manhattanDistance = (a: Node, endPosition: NodePosition): number => {\r\n  const { row, column } = a.position;\r\n  return (\r\n    Math.abs(row - endPosition.row) + Math.abs(column - endPosition.column)\r\n  );\r\n};\r\n\r\nconst getGScore = (node: Node): number => {\r\n  const props = node.props as AStarProps;\r\n  return props.g;\r\n};\r\n\r\nconst setGScore = (node: Node, value: number) => {\r\n  const props = node.props as AStarProps;\r\n  props.g = value;\r\n};\r\n\r\nconst setFScore = (node: Node, value: number) => {\r\n  const props = node.props as AStarProps;\r\n  props.f = value;\r\n};\r\n","import React, { useEffect } from \"react\";\r\nimport {\r\n  useSetRecoilState,\r\n  useRecoilCallback,\r\n  useRecoilState,\r\n  useRecoilValue,\r\n} from \"recoil\";\r\nimport \"../css/grid.scss\";\r\nimport {\r\n  nodeAtom,\r\n  isVisualizedAtom,\r\n  visitedNodesAtom,\r\n  shortestPathNodesAtom,\r\n  selectedAlgorithmAtom,\r\n} from \"../state/atoms\";\r\nimport { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\nimport GridNode from \"./GridNode\";\r\nimport { Algorithm, Node, NodePosition, VoidFunction } from \"../types\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport { aStar } from \"../algorithms/astar\";\r\n\r\ninterface GridProps {\r\n  setOnVisualize: (childVisualize: VoidFunction) => void;\r\n  setOnReset: (childReset: VoidFunction) => void;\r\n  setOnClearPath: (childClearPath: VoidFunction) => void;\r\n}\r\n\r\nconst startPositionFuncs: (() => NodePosition)[] = [];\r\nconst endPositionFuncs: (() => NodePosition)[] = [];\r\nconst clearNodeFuncs: VoidFunction[] = [];\r\n\r\nconst getShortestPath = (endNode: Node): Node[] => {\r\n  const shortestPath: Node[] = [];\r\n  let node: Node | undefined = endNode;\r\n  while (node) {\r\n    shortestPath.push(node);\r\n    node = node.parent;\r\n  }\r\n  return shortestPath;\r\n};\r\n\r\nconst getArrayIndex = (array: Node[], row: number, column: number): number => {\r\n  return array.length !== 0\r\n    ? array.findIndex(\r\n        (node) => node.position.row === row && node.position.column === column\r\n      )\r\n    : -1;\r\n};\r\n\r\nconst getNodePositionFromChildren = (\r\n  positionFuncs: (() => NodePosition)[]\r\n): NodePosition => {\r\n  let nodePosition = { row: -1, column: -1 };\r\n  for (let positionFunc of positionFuncs) {\r\n    const childPosition = positionFunc();\r\n    if (childPosition) {\r\n      nodePosition = childPosition;\r\n      break;\r\n    }\r\n  }\r\n  return nodePosition;\r\n};\r\n\r\nconst getStartNodePosition = (): NodePosition => {\r\n  return getNodePositionFromChildren(startPositionFuncs);\r\n};\r\n\r\nconst getEndNodePosition = (): NodePosition => {\r\n  return getNodePositionFromChildren(endPositionFuncs);\r\n};\r\n\r\nconst Grid = ({ setOnVisualize, setOnReset, setOnClearPath }: GridProps) => {\r\n  const setIsStartPosition = (\r\n    childStartPosition: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    startPositionFuncs[childIndex] = childStartPosition;\r\n  };\r\n  const setIsEndPosition = (\r\n    childEndPosition: () => NodePosition,\r\n    childIndex: number\r\n  ) => {\r\n    endPositionFuncs[childIndex] = childEndPosition;\r\n  };\r\n  const setClearNode = (childClearNode: VoidFunction, childIndex: number) => {\r\n    clearNodeFuncs[childIndex] = childClearNode;\r\n  };\r\n  const setIsVisualized = useSetRecoilState(isVisualizedAtom);\r\n  const [visitedNodes, setVisitedNodes] = useRecoilState(visitedNodesAtom);\r\n  const [shortestPathNodes, setShortestPathNodes] = useRecoilState(\r\n    shortestPathNodesAtom\r\n  );\r\n  const selectedAlgorithm = useRecoilValue(selectedAlgorithmAtom);\r\n  useEffect(() => {\r\n    setOnVisualize(() => {\r\n      visualizeAlgorithm();\r\n      setIsVisualized(true);\r\n    });\r\n    setOnReset(() => {\r\n      resetGridState();\r\n      setVisitedNodes([]);\r\n      setShortestPathNodes([]);\r\n      setIsVisualized(false);\r\n    });\r\n    setOnClearPath(() => {\r\n      clearNodeFuncs.forEach((clearFunc) => clearFunc());\r\n      setVisitedNodes([]);\r\n      setShortestPathNodes([]);\r\n      setIsVisualized(false);\r\n    });\r\n  });\r\n  const getGridState = useRecoilCallback(\r\n    ({ snapshot: { getLoadable } }) =>\r\n      () => {\r\n        let nodes: Node[] = [];\r\n        for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n          for (let j = 0; j < NUM_OF_NODES; j++) {\r\n            const nodeValue = getLoadable(nodeAtom([i, j])).getValue();\r\n            nodes = [...nodes, JSON.parse(JSON.stringify(nodeValue))];\r\n          }\r\n        }\r\n        return nodes;\r\n      }\r\n  );\r\n  const resetGridState = useRecoilCallback(({ reset }) => () => {\r\n    for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n      for (let j = 0; j < NUM_OF_NODES; j++) {\r\n        reset(nodeAtom([i, j]));\r\n      }\r\n    }\r\n  });\r\n  const visualizeAlgorithm = () => {\r\n    const startNodePosition = getStartNodePosition();\r\n    const endNodePosition = getEndNodePosition();\r\n    const gridNodes = getGridState();\r\n    let newVisitedNodes: Node[] = [];\r\n    switch (selectedAlgorithm) {\r\n      case Algorithm.Dijkstra:\r\n        newVisitedNodes = dijkstra(\r\n          gridNodes,\r\n          startNodePosition,\r\n          endNodePosition\r\n        );\r\n        break;\r\n      case Algorithm.AStar:\r\n        newVisitedNodes = aStar(gridNodes, startNodePosition, endNodePosition);\r\n        break;\r\n    }\r\n    const endNode = newVisitedNodes[newVisitedNodes.length - 1];\r\n    if (\r\n      endNode.position.row === endNodePosition.row &&\r\n      endNode.position.column === endNodePosition.column\r\n    ) {\r\n      setShortestPathNodes(getShortestPath(endNode));\r\n    }\r\n    setVisitedNodes(newVisitedNodes);\r\n  };\r\n  return (\r\n    <div className=\"grid\">\r\n      {Array.from(Array(NUM_OF_ROWS * NUM_OF_NODES).keys()).map((index) => {\r\n        const row = Math.floor(index / NUM_OF_NODES);\r\n        const column = index % NUM_OF_NODES;\r\n        return (\r\n          <GridNode\r\n            position={{ row, column }}\r\n            visitedNumber={getArrayIndex(visitedNodes, row, column)}\r\n            visitedCount={visitedNodes.length}\r\n            pathNumber={getArrayIndex(\r\n              shortestPathNodes.slice().reverse(),\r\n              row,\r\n              column\r\n            )}\r\n            setIsStartPosition={setIsStartPosition}\r\n            setIsEndPosition={setIsEndPosition}\r\n            setClearNode={setClearNode}\r\n            key={index}\r\n          ></GridNode>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import React, { useState } from \"react\";\r\nimport Menu from \"@mui/material/Menu\";\r\nimport MenuItem from \"@mui/material/MenuItem\";\r\nimport { useSetRecoilState } from \"recoil\";\r\nimport { selectedAlgorithmAtom } from \"../../state/atoms\";\r\nimport { Algorithm } from \"../../types\";\r\nimport Button from \"@mui/material/Button\";\r\nimport { BsFillCaretDownFill } from \"react-icons/bs\";\r\n\r\nconst AlgorithmMenu = () => {\r\n  const setSelectedAlgorithm = useSetRecoilState(selectedAlgorithmAtom);\r\n  const [menuAnchorElement, setMenuAnchorElement] =\r\n    useState<HTMLElement | null>(null);\r\n  const open = Boolean(menuAnchorElement);\r\n  const handleAlgorithmChange = (event: any) => {\r\n    const { myValue: selectedAlgorithm } = event.currentTarget.dataset;\r\n    setSelectedAlgorithm(selectedAlgorithm);\r\n    setMenuAnchorElement(null);\r\n  };\r\n  const handleAlgorithmMenuClick = (event: React.MouseEvent<HTMLElement>) => {\r\n    setMenuAnchorElement(event.currentTarget);\r\n  };\r\n  return (\r\n    <span>\r\n      <Button\r\n        sx={{ mx: \"5px\", backgroundColor: \"#FF9500\" }}\r\n        color=\"inherit\"\r\n        size=\"small\"\r\n        aria-haspopup=\"true\"\r\n        aria-expanded={open ? \"true\" : undefined}\r\n        endIcon={<BsFillCaretDownFill size=\"12\" />}\r\n        onClick={handleAlgorithmMenuClick}\r\n      >\r\n        Algorithms\r\n      </Button>\r\n      <Menu\r\n        id=\"selectedAlgorithm\"\r\n        open={open}\r\n        anchorEl={menuAnchorElement}\r\n        onClose={() => setMenuAnchorElement(null)}\r\n      >\r\n        <MenuItem\r\n          data-my-value={Algorithm.Dijkstra}\r\n          onClick={handleAlgorithmChange}\r\n        >\r\n          Dijkstra\r\n        </MenuItem>\r\n        <MenuItem\r\n          data-my-value={Algorithm.AStar}\r\n          onClick={handleAlgorithmChange}\r\n        >\r\n          A*\r\n        </MenuItem>\r\n      </Menu>\r\n    </span>\r\n  );\r\n};\r\n\r\nexport default AlgorithmMenu;\r\n","import React, { useState } from \"react\";\r\nimport Menu from \"@mui/material/Menu\";\r\nimport MenuItem from \"@mui/material/MenuItem\";\r\nimport Button from \"@mui/material/Button\";\r\nimport { BsFillCaretDownFill } from \"react-icons/bs\";\r\nimport { useRecoilCallback, useRecoilValue } from \"recoil\";\r\nimport { nodeAtom, visualizationSpeedAtom } from \"../../state/atoms\";\r\nimport { getRandomPatternWalls } from \"../../patterns/random\";\r\nimport { getRecursiveDivisionWallNodes } from \"../../patterns/recursive\";\r\n\r\ninterface PatternMenuProps {\r\n  isDisabled: boolean;\r\n}\r\n\r\nconst PatternMenu = ({ isDisabled }: PatternMenuProps) => {\r\n  const visualizationSpeed = useRecoilValue(visualizationSpeedAtom);\r\n  const [menuAnchorElement, setMenuAnchorElement] =\r\n    useState<HTMLElement | null>(null);\r\n  const open = Boolean(menuAnchorElement);\r\n  const handlePatternMenuClick = (event: React.MouseEvent<HTMLElement>) => {\r\n    setMenuAnchorElement(event.currentTarget);\r\n  };\r\n  const handleRandomMazeClick = () => {\r\n    setMenuAnchorElement(null);\r\n    generateRandomMaze();\r\n  };\r\n  const handleRecursiveDivisionClick = () => {\r\n    setMenuAnchorElement(null);\r\n    generateRecursiveDivisionMaze();\r\n  };\r\n  const generateRandomMaze = useRecoilCallback(\r\n    ({ set, snapshot: { getLoadable } }) =>\r\n      () => {\r\n        const getNodeFunction = (i: number, j: number) => {\r\n          return getLoadable(nodeAtom([i, j])).getValue();\r\n        };\r\n        getRandomPatternWalls(getNodeFunction).forEach((wallNode) => {\r\n          const { row, column } = wallNode.position;\r\n          set(nodeAtom([row, column]), {\r\n            ...wallNode,\r\n            flags: {\r\n              ...wallNode.flags,\r\n              isVisited: false,\r\n              isPath: false,\r\n              isWall: true,\r\n            },\r\n          });\r\n        });\r\n      }\r\n  );\r\n  const generateRecursiveDivisionMaze = useRecoilCallback(\r\n    ({ set, snapshot: { getLoadable } }) =>\r\n      () => {\r\n        const getNodeFunction = (i: number, j: number) => {\r\n          return getLoadable(nodeAtom([i, j])).getValue();\r\n        };\r\n        getRecursiveDivisionWallNodes(getNodeFunction)\r\n          .sort((a, b) => {\r\n            return a.position.column - b.position.column;\r\n          })\r\n          .filter((wallNode) => {\r\n            const { isStart, isEnd } = wallNode.flags;\r\n            return !isStart && !isEnd;\r\n          })\r\n          .forEach((wallNode, i) => {\r\n            const { row, column } = wallNode.position;\r\n            setTimeout(() => {\r\n              set(nodeAtom([row, column]), {\r\n                ...wallNode,\r\n                flags: {\r\n                  ...wallNode.flags,\r\n                  isVisited: false,\r\n                  isPath: false,\r\n                  isWall: true,\r\n                },\r\n              });\r\n            }, (visualizationSpeed * (i + 1)) / 2);\r\n          });\r\n      }\r\n  );\r\n  return (\r\n    <span>\r\n      <Button\r\n        sx={{\r\n          \"&\": { mx: \"5px\", backgroundColor: \"#FF9500\" },\r\n          \"&:disabled\": {\r\n            color: \"white\",\r\n            backgroundColor: \"#B4876C\",\r\n          },\r\n        }}\r\n        color=\"inherit\"\r\n        size=\"small\"\r\n        aria-haspopup=\"true\"\r\n        aria-expanded={open ? \"true\" : undefined}\r\n        endIcon={<BsFillCaretDownFill size=\"12\" />}\r\n        onClick={handlePatternMenuClick}\r\n        disabled={isDisabled}\r\n      >\r\n        Patterns\r\n      </Button>\r\n      <Menu\r\n        id=\"selectedPattern\"\r\n        open={open}\r\n        anchorEl={menuAnchorElement}\r\n        onClose={() => setMenuAnchorElement(null)}\r\n      >\r\n        <MenuItem onClick={handleRandomMazeClick}>Random maze</MenuItem>\r\n        <MenuItem onClick={handleRecursiveDivisionClick}>\r\n          Recursive division\r\n        </MenuItem>\r\n      </Menu>\r\n    </span>\r\n  );\r\n};\r\n\r\nexport default PatternMenu;\r\n","import { NUM_OF_NODES, NUM_OF_ROWS } from \"../state/constants\";\r\nimport { Node, GetNodeFunction } from \"../types\";\r\n\r\nexport const getRandomPatternWalls = (getNode: GetNodeFunction): Node[] => {\r\n  const wallNodes = [];\r\n  for (let i = 0; i < NUM_OF_ROWS; i++) {\r\n    for (let j = 0; j < NUM_OF_NODES; j++) {\r\n      const nodeValue = getNode(i, j);\r\n      const { isStart, isEnd } = nodeValue.flags;\r\n      const randomFactor = Math.random();\r\n      if (randomFactor > 0.7 && !isStart && !isEnd) {\r\n        wallNodes.push(nodeValue);\r\n      }\r\n    }\r\n  }\r\n  return wallNodes;\r\n};\r\n","import React from \"react\";\r\nimport RadioGroup from \"@mui/material/RadioGroup\";\r\nimport FormControlLabel from \"@mui/material/FormControlLabel\";\r\nimport Radio from \"@mui/material/Radio\";\r\nimport { useRecoilState } from \"recoil\";\r\nimport { visualizationSpeedAtom } from \"../../state/atoms\";\r\nimport { VisualizationSpeed } from \"../../types\";\r\nimport { FormControl, FormLabel } from \"@mui/material\";\r\n\r\nconst SpeedSelection = () => {\r\n  const [visualizationSpeed, setVisualizationSpeed] = useRecoilState(\r\n    visualizationSpeedAtom\r\n  );\r\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    setVisualizationSpeed(Number((event.target as HTMLInputElement).value));\r\n  };\r\n  return (\r\n    <FormControl sx={{ ml: 2 }}>\r\n      <FormLabel sx={{ color: \"black\", fontWeight: \"bold\", mt: 1 }}>\r\n        Speed\r\n      </FormLabel>\r\n      <RadioGroup value={visualizationSpeed} onChange={handleChange}>\r\n        {Object.keys(VisualizationSpeed)\r\n          .filter((speed) => !isNaN(Number(speed)))\r\n          .map((speed) => {\r\n            return (\r\n              <FormControlLabel\r\n                key={speed}\r\n                value={Number(speed)}\r\n                control={<Radio />}\r\n                label={VisualizationSpeed[Number(speed)]}\r\n              />\r\n            );\r\n          })}\r\n      </RadioGroup>\r\n    </FormControl>\r\n  );\r\n};\r\n\r\nexport default SpeedSelection;\r\n","import React from \"react\";\r\nimport { FormControlLabel, Radio } from \"@mui/material\";\r\n\r\ninterface WeightNodeRowProps {\r\n  weight: number;\r\n  color: string;\r\n}\r\n\r\nconst WeightNodeRow = ({ weight, color }: WeightNodeRowProps) => {\r\n  return (\r\n    <div style={{ display: \"flex\", alignItems: \"center\" }}>\r\n      <FormControlLabel\r\n        value={color}\r\n        control={<Radio />}\r\n        label={`Weight:`}\r\n        sx={{ mr: \"5px\" }}\r\n      />\r\n      <span\r\n        style={{\r\n          width: \"20px\",\r\n          height: \"20px\",\r\n          border: `2px solid ${color}`,\r\n          display: \"inline-flex\",\r\n          justifyContent: \"center\",\r\n          alignItems: \"center\",\r\n        }}\r\n      >\r\n        {weight}\r\n      </span>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WeightNodeRow;\r\n","import React from \"react\";\r\nimport { WeightNode } from \"../../types\";\r\nimport WeightNodeRow from \"./WeightNodeRow\";\r\nimport { FormControl, FormLabel, RadioGroup } from \"@mui/material\";\r\nimport { useRecoilValue, useRecoilState } from \"recoil\";\r\nimport { selectedWeightNodeAtom, weightNodesAtom } from \"../../state/atoms\";\r\n\r\nconst WeightNodeSelection = () => {\r\n  const weightNodes = useRecoilValue(weightNodesAtom);\r\n  const [selectedWeightNode, setSelectedWeightNode] = useRecoilState(\r\n    selectedWeightNodeAtom\r\n  );\r\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const color = (event.target as HTMLInputElement).value;\r\n    const newWeightNode = weightNodes.find((weightNode) => {\r\n      return weightNode.color === color;\r\n    });\r\n    if (newWeightNode) {\r\n      setSelectedWeightNode(newWeightNode);\r\n    }\r\n  };\r\n  return (\r\n    <FormControl sx={{ flex: \"2\", ml: 2 }}>\r\n      <FormLabel sx={{ color: \"black\", fontWeight: \"bold\", mt: 1 }}>\r\n        Weight nodes\r\n      </FormLabel>\r\n      <RadioGroup value={selectedWeightNode.color} onChange={handleChange}>\r\n        {[...weightNodes]\r\n          .sort((a, b) => a.weight - b.weight)\r\n          .map((weightNode: WeightNode, i) => {\r\n            return (\r\n              <WeightNodeRow\r\n                key={i}\r\n                weight={weightNode.weight}\r\n                color={weightNode.color}\r\n              />\r\n            );\r\n          })}\r\n      </RadioGroup>\r\n    </FormControl>\r\n  );\r\n};\r\n\r\nexport default WeightNodeSelection;\r\n","import React from \"react\";\r\nimport RadioGroup from \"@mui/material/RadioGroup\";\r\nimport FormControlLabel from \"@mui/material/FormControlLabel\";\r\nimport Radio from \"@mui/material/Radio\";\r\nimport { useRecoilState } from \"recoil\";\r\nimport { FormControl, FormLabel } from \"@mui/material\";\r\nimport { DrawingMode } from \"../../types\";\r\nimport { drawingModeAtom } from \"../../state/atoms\";\r\n\r\nconst DrawingModeSelection = () => {\r\n  const [drawingMode, setDrawingMode] = useRecoilState(drawingModeAtom);\r\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const value = (event.target as HTMLInputElement).value;\r\n    if (value === \"Wall\") {\r\n      setDrawingMode(DrawingMode.Wall);\r\n    } else {\r\n      setDrawingMode(DrawingMode.Weighted);\r\n    }\r\n  };\r\n  return (\r\n    <FormControl sx={{ ml: 2 }}>\r\n      <FormLabel sx={{ color: \"black\", fontWeight: \"bold\", mt: 1 }}>\r\n        Drawing mode\r\n      </FormLabel>\r\n      <RadioGroup value={drawingMode} onChange={handleChange}>\r\n        {Object.keys(DrawingMode).map((mode) => {\r\n          return (\r\n            <FormControlLabel\r\n              key={mode}\r\n              value={mode}\r\n              control={<Radio />}\r\n              label={mode}\r\n            />\r\n          );\r\n        })}\r\n      </RadioGroup>\r\n    </FormControl>\r\n  );\r\n};\r\n\r\nexport default DrawingModeSelection;\r\n","import React, { useState } from \"react\";\r\nimport { FormControl, TextField, IconButton } from \"@mui/material\";\r\nimport { Color, ColorPicker, createColor } from \"material-ui-color\";\r\nimport { FiPlus } from \"react-icons/fi\";\r\nimport { useRecoilState } from \"recoil\";\r\nimport { weightNodesAtom } from \"../../state/atoms\";\r\n\r\nconst DEFAULT_COLOR = createColor(\"#ff0000\");\r\n\r\nconst WeightNodeForm = () => {\r\n  const [weightNodes, setWeightNodes] = useRecoilState(weightNodesAtom);\r\n  const [color, setColor] = useState<Color>(DEFAULT_COLOR);\r\n  const [weight, setWeight] = useState<number>(0);\r\n  const handleColorChange = (newValue: Color) => {\r\n    setColor(newValue);\r\n  };\r\n  const handleWeightChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const newValue = e.target.value;\r\n    setWeight(Number(newValue));\r\n  };\r\n  const handleAddWeightNode = () => {\r\n    setWeightNodes([...weightNodes, { weight, color: `#${color.hex}` }]);\r\n    setColor(DEFAULT_COLOR);\r\n    setWeight(0);\r\n  };\r\n  return (\r\n    <div\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        flexDirection: \"column\",\r\n        alignItems: \"center\",\r\n        margin: \"1em 0\",\r\n      }}\r\n    >\r\n      <FormControl\r\n        sx={{\r\n          display: \"flex\",\r\n          flexDirection: \"row\",\r\n          flexWrap: \"wrap\",\r\n          mx: 2,\r\n          justifyContent: \"center\",\r\n          alignItems: \"center\",\r\n          flex: \"1\",\r\n        }}\r\n      >\r\n        <TextField\r\n          inputProps={{ inputMode: \"numeric\", pattern: \"[0-9]+\" }}\r\n          label=\"Weight\"\r\n          size=\"small\"\r\n          value={weight}\r\n          sx={{ width: \"50%\" }}\r\n          onChange={handleWeightChange}\r\n        />\r\n        <ColorPicker value={color} onChange={handleColorChange} hideTextfield />\r\n        <IconButton sx={{ p: 0 }} onClick={handleAddWeightNode}>\r\n          <FiPlus />\r\n        </IconButton>\r\n      </FormControl>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WeightNodeForm;\r\n","import React, { useState } from \"react\";\r\nimport { GiHamburgerMenu } from \"react-icons/gi\";\r\nimport Drawer from \"@mui/material/Drawer\";\r\nimport Divider from \"@mui/material/Divider\";\r\nimport IconButton from \"@mui/material/Divider\";\r\nimport SpeedSelection from \"./SpeedSelection\";\r\nimport WeightNodeSelection from \"./WeightNodeSelection\";\r\nimport DrawingModeSelection from \"./DrawingModeSelection\";\r\nimport WeightNodeForm from \"./WeightNodeForm\";\r\n\r\nconst ConfigurationDrawer = () => {\r\n  const [open, setOpen] = useState<boolean>(false);\r\n  const toggleDrawer = (newOpen: boolean) => (event: React.MouseEvent) => {\r\n    if (event.type === \"keydown\") {\r\n      return;\r\n    }\r\n    setOpen(newOpen);\r\n  };\r\n  return (\r\n    <div>\r\n      <React.Fragment key={\"configurationDrawer\"}>\r\n        <IconButton onClick={toggleDrawer(true)}>\r\n          <GiHamburgerMenu />\r\n        </IconButton>\r\n        <Drawer\r\n          anchor={\"right\"}\r\n          open={open}\r\n          onClose={toggleDrawer(false)}\r\n          PaperProps={{\r\n            sx: {\r\n              width: \"20vw\",\r\n              display: \"flex\",\r\n              backgroundImage: \"linear-gradient(lightgray, white, lightgray)\",\r\n              flexDirection: \"column\",\r\n            },\r\n          }}\r\n        >\r\n          <DrawingModeSelection />\r\n          <Divider />\r\n          <WeightNodeSelection />\r\n          <Divider />\r\n          <WeightNodeForm />\r\n          <Divider />\r\n\r\n          <SpeedSelection />\r\n        </Drawer>\r\n      </React.Fragment>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ConfigurationDrawer;\r\n","import React from \"react\";\r\nimport Button from \"@mui/material/Button\";\r\nimport Typography from \"@mui/material/Typography\";\r\nimport Box from \"@mui/material/Box\";\r\nimport { useRecoilValue } from \"recoil\";\r\nimport { isVisualizedAtom, selectedAlgorithmAtom } from \"../state/atoms\";\r\nimport AppBar from \"@mui/material/AppBar\";\r\nimport Toolbar from \"@mui/material/Toolbar\";\r\nimport \"../css/controls.scss\";\r\nimport AlgorithmMenu from \"./menu/AlgorithmMenu\";\r\nimport { VoidFunction } from \"../types\";\r\nimport PatternMenu from \"./menu/PatternMenu\";\r\nimport ConfigurationDrawer from \"./drawer/ConfigurationDrawer\";\r\n\r\ninterface ControlsProps {\r\n  visualizeGrid: VoidFunction;\r\n  resetGrid: VoidFunction;\r\n  clearPath: VoidFunction;\r\n}\r\n\r\nconst Controls = ({ visualizeGrid, resetGrid, clearPath }: ControlsProps) => {\r\n  const selectedAlgorithm = useRecoilValue(selectedAlgorithmAtom);\r\n  const isVisualized = useRecoilValue(isVisualizedAtom);\r\n  return (\r\n    <div className=\"controls\">\r\n      <AppBar\r\n        position=\"static\"\r\n        sx={{\r\n          alignItems: \"center\",\r\n          mb: \"5%\",\r\n          backgroundColor: \"#FFA254\",\r\n        }}\r\n      >\r\n        <Toolbar id=\"toolbar\" variant=\"dense\" sx={{ width: \"100%\" }}>\r\n          <Typography\r\n            variant=\"h4\"\r\n            sx={{ ml: 3, fontFamily: \"Dancing Script\", fontWeight: 700 }}\r\n          >\r\n            Pathfinder\r\n          </Typography>\r\n          <Box\r\n            sx={{\r\n              display: \"flex\",\r\n              justifyContent: \"space-evenly\",\r\n              alignItems: \"center\",\r\n              flexDirection: \"row\",\r\n              flex: 1,\r\n            }}\r\n          >\r\n            <div>\r\n              <AlgorithmMenu />\r\n              <PatternMenu isDisabled={isVisualized} />\r\n            </div>\r\n            <Button\r\n              size=\"medium\"\r\n              color=\"inherit\"\r\n              sx={{\r\n                \"&\": { mx: \"5px\", backgroundColor: \"#FF7800\" },\r\n                \"&:hover\": {\r\n                  backgroundColor: \"#FF7800\",\r\n                  transform: \"translateY(-2px)\",\r\n                },\r\n                \"&:disabled\": {\r\n                  color: \"white\",\r\n                  backgroundColor: \"#B4876C\",\r\n                },\r\n              }}\r\n              disabled={isVisualized}\r\n              onClick={visualizeGrid}\r\n            >\r\n              {`Visualize ${selectedAlgorithm}`}\r\n            </Button>\r\n            <div>\r\n              <Button\r\n                size=\"small\"\r\n                color=\"inherit\"\r\n                sx={{ mx: \"5px\", backgroundColor: \"#FF9500\" }}\r\n                onClick={resetGrid}\r\n              >\r\n                Reset grid\r\n              </Button>\r\n              <Button\r\n                size=\"small\"\r\n                color=\"inherit\"\r\n                sx={{ mx: \"5px\", backgroundColor: \"#FF9500\" }}\r\n                onClick={clearPath}\r\n              >\r\n                Clear path\r\n              </Button>\r\n            </div>\r\n          </Box>\r\n          <Box sx={{ mr: 3, display: \"flex\", justifyContent: \"flex-end\" }}>\r\n            <ConfigurationDrawer />\r\n          </Box>\r\n        </Toolbar>\r\n      </AppBar>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Controls;\r\n","import React from \"react\";\r\nimport Grid from \"./Grid\";\r\nimport Controls from \"./Controls\";\r\nimport \"../css/app.scss\";\r\nimport { VoidFunction } from \"../types\";\r\n\r\nlet visualizeGrid: VoidFunction = () => {};\r\nlet resetGrid: VoidFunction = () => {};\r\nlet clearPath: VoidFunction = () => {};\r\n\r\nconst App = () => {\r\n  const setOnVisualize = (childVisualize: VoidFunction) => {\r\n    visualizeGrid = childVisualize;\r\n  };\r\n  const setOnReset = (childReset: VoidFunction) => {\r\n    resetGrid = childReset;\r\n  };\r\n  const setOnClearPath = (childClearPath: VoidFunction) => {\r\n    clearPath = childClearPath;\r\n  };\r\n  return (\r\n    <div className=\"container\">\r\n      <Controls\r\n        visualizeGrid={() => visualizeGrid()}\r\n        resetGrid={() => resetGrid()}\r\n        clearPath={() => clearPath()}\r\n      ></Controls>\r\n      <Grid\r\n        setOnVisualize={setOnVisualize}\r\n        setOnReset={setOnReset}\r\n        setOnClearPath={setOnClearPath}\r\n      ></Grid>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { RecoilRoot } from \"recoil\";\r\nimport \"./css/index.scss\";\r\nimport App from \"./components/App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <RecoilRoot>\r\n      <App />\r\n    </RecoilRoot>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}